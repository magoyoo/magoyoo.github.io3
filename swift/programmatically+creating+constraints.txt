1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/98e4530578c425d7.css",{"as":"style"}]
0:["BTzIZmIeYXT3BlsSUt3SU",[[["",{"children":["swift",{"children":[["slug","programmatically%2Bcreating%2Bconstraints","d"],{"children":["__PAGE__?{\"slug\":\"programmatically+creating+constraints\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/98e4530578c425d7.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":42879,"chunks":["185:static/chunks/app/layout-b198f10c98e34978.js"],"name":"GoogleAnalytics","async":false}
6:I{"id":47767,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
7:I{"id":57920,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
3:[null,["$","html",null,{"lang":"ko","children":[["$","$L5",null,{}],["$","body",null,{"className":"__className_aaf875","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","swift","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","swift","children",["slug","programmatically%2Bcreating%2Bconstraints","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"programmatically+creating+constraints\"}"},"styles":[]}],"segment":["slug","programmatically%2Bcreating%2Bconstraints","d"]},"styles":[]}],"segment":"swift"},"styles":[]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"[번역] Programmatically Creating Constraints - Advanced Auto Layout | 마고자비 블로그"}],["$","meta","2",{"name":"description","content":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다."}],["$","meta","3",{"name":"keywords","content":"swift,auth layout,document,번역,UIKit"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"}],["$","link","5",{"rel":"canonical","href":"https://magomercy.com/swift/programmatically+creating+constraints"}],["$","meta","6",{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta","7",{"name":"apple-mobile-web-app-title","content":"[번역] Programmatically Creating Constraints - Advanced Auto Layout | 마고자비 블로그"}],["$","meta","8",{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta","9",{"property":"og:title","content":"[번역] Programmatically Creating Constraints - Advanced Auto Layout | 마고자비 블로그"}],["$","meta","10",{"property":"og:description","content":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다."}],["$","meta","11",{"property":"og:url","content":"https://magomercy.com/swift/programmatically+creating+constraints"}],["$","meta","12",{"property":"og:site_name","content":"마고자비 블로그 | 마구잡이로 하고 싶은 것을 합니다."}],["$","meta","13",{"property":"og:locale","content":"kr"}],["$","meta","14",{"property":"og:image","content":"https://magomercy.com/images/auto0301.jpg"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary"}],["$","meta","17",{"name":"twitter:creator","content":"마고자비 블로그"}],["$","meta","18",{"name":"twitter:title","content":"[번역] Programmatically Creating Constraints - Advanced Auto Layout | 마고자비 블로그"}],["$","meta","19",{"name":"twitter:description","content":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다."}],["$","meta","20",{"name":"twitter:image","content":"https://magomercy.com/images/auto0301.jpg"}],["$","link","21",{"rel":"icon","href":"https://magomercy.com/favicon32.png"}],["$","link","22",{"rel":"apple-touch-icon","href":"https://magomercy.com/favicon32.png"}],["$","meta","23",{"name":"next-size-adjust"}]]
a:I{"id":22873,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
b:I{"id":84423,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
c:I{"id":2346,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
d:I{"id":62313,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
16:I{"id":67490,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"MarkDownCode","async":false}
18:I{"id":63222,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"Image","async":false}
26:I{"id":87272,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
27:I{"id":55026,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
e:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
f:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
10:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
11:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
12:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
13:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
14:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
15:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
17:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
19:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1a:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1b:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1c:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1d:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1e:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
1f:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
20:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
21:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
22:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
23:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
24:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
25:T32ac,
# 개요

---

> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.

# Programmatically Creating Constraints

---

가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다.

Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다([Working with Constraints in Interface Builder](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1) 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며([Debugging Auto Layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1) 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다([Dynamic Stack View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19) 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다.

프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다.

# Layout Anchors

---

NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다.

> NOTE
>
> iOS에서 뷰에는  [layoutMarginsGuide](https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide) 및  [readableContentGuide](https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide) 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 [UILayoutGuide](https://developer.apple.com/documentation/uikit/uilayoutguide)  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.
> 프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요.

레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다.

```swift
// Get the superview's layout
let margins = view.layoutMarginsGuide

// Pin the leading edge of myView to the margin's leading edge
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true

// Pin the trailing edge of myView to the margin's trailing edge
myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true

// Give myView a 1:2 aspect ratio
myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
```

[Anatomy of a Constraint](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다.

![image01](/images/auto0301.jpg)

레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:

```swift
myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true
```

기호는 방정식의 다음 부분에 해당합니다.

![image02](/images/auto0902.jpg)

레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커([leadingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor) 또는 [trailingAnchor](https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor))를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다.

> NOTE
>
> 이러한 규칙은 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다.

자세한 내용은  *[NSLayoutAnchor Class Reference](https://developer.apple.com/documentation/appkit/nslayoutanchor)를* 참조하세요.

# NSLayoutConstraint Class

---

또한 [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init) 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다([The constraint equation](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2) 참조).

또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조).

레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다.

```swift
NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true

NSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true
```

> NOTE
>
> 레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.
> 자세한 내용은 *[NSLayoutConstraint Class Reference](https://developer.apple.com/documentation/uikit/nslayoutconstraint)*를 참조하십시오.

# Visual Format Language

---

**Visual Format Language**를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다.

오토 레이아웃은 **Visual Format Language**를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다.

**Visual Format Language**를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다.

**Visual Format Language**를 사용하면 유효한 제약 조건만 만들 수 있습니다.

표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다.

컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다.

위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다.

```swift
let views = ["myView" : myView]
let formatString = "|-[myView]-|"

let constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)

NSLayoutConstraint.activate(constraints)
```

이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. **Visual Format Language**는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다.

한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 "Align All Top" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음).

시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오.

1. 뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오.

> NOTE
>
> Objective-C를 사용할 때 [NSDictionaryOfVariableBindings](https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings) 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다.

2. (Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다.
3. 항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다.
4. [NSLayoutConstraint](https://developer.apple.com/documentation/uikit/nslayoutconstraint) 클래스의 [constraintsWithVisualFormat:options:metrics:views:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints) 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다.
5. NSLayoutConstraint 클래스의 [activateConstraints:](https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate) 메소드를 호출하여 제약 조건을 활성화합니다.

자세한 내용은 [Visual Format Language](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1) 부록을 참조하십시오.
9:[["$","$La",null,{"language":"kr","screenType":"ARTICLE_DETAIL"}],["$","section",null,{"className":"flex fixed top-0 left-0 w-full  md:h-[600px] h-[300px] justify-center","style":{"backgroundImage":"url(/images/auto0301.jpg)","backgroundPosition":"center","backgroundSize":"contain","backgroundRepeat":"no-repeat"},"children":[["$","div",null,{"className":"w-full md:h-[600px] h-[300px]  bg-[#171E24] bg-opacity-[0.35] absolute top-0 left-0"}],["$","div",null,{"className":"hidden md:flex flex-col justify-end w-[100%] md:w-[700px] px-[20px] pb-[100px]","children":["$","h1",null,{"className":"font-semibold text-[40px] text-gray-100 text-shadow-default z-40","children":"[번역] Programmatically Creating Constraints - Advanced Auto Layout"}]}]]}],["$","main",null,{"className":"flex flex-row justify-center md:py-[120px] py-[60px] bg-white md:mt-[600px] mt-[300px] relative z-30 ","children":[["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","div",null,{"className":"toc sticky top-[90px] flex flex-col","children":["$","$Lb",null,{}]}]}],["$","article",null,{"className":"flex flex-col w-full md:w-[600px] px-[20px] md:px-[0px] gap-[40px]","children":[["$","div",null,{"className":"md:hidden border-b-[0.6px] pb-[40px] border-gray-200","children":["$","h1",null,{"className":"text-[28px] font-bold leading-[150%]","children":"[번역] Programmatically Creating Constraints - Advanced Auto Layout"}]}],["$","div",null,{"className":"flex flex-col","children":[["$","$Lc",null,{}],["$","div",null,{"children":["작성일 : ",["$","time",null,{"children":"2023-05-04"}]]}]]}],["$","div",null,{"children":["$","div",null,{"className":"md-to-html","children":[["$","h1",null,{"id":"476966c5","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"개요"}],"\n",["$","hr","hr-0",{}],"\n",["$","blockquote",null,{"className":"bg-gray-100 p-[40px] md:my-[30px] my-[20px] rounded-[16px]","children":["\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["해당 문서는 학습 목적으로 Apple 공식 문서인 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/"},"children":[{"type":"text","value":"Auto Layout Guide","position":{"start":{"line":6,"column":32,"offset":43},"end":{"line":6,"column":49,"offset":60}}}],"position":{"start":{"line":6,"column":31,"offset":42},"end":{"line":6,"column":149,"offset":160}}},"children":"Auto Layout Guide"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$e","category":"swift"},"language":"kr"}],"을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다."]}],"\n"]}],"\n",["$","h1",null,{"id":"53c7994a","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"Programmatically Creating Constraints"}],"\n",["$","hr","hr-1",{}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"가능할 때마다 Interface Builder를 사용하여 제약 조건을 설정하십시오. Interface Builder는 제약 조건을 시각화, 편집, 관리 및 디버깅할 수 있는 다양한 도구를 제공합니다. 제약 조건을 분석하면 디자인 타임에 많은 일반적인 오류가 나타나므로 앱이 실행되기도 전에 문제를 찾아 수정할 수 있습니다."}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["Interface Builder는 계속 증가하는 작업을 관리할 수 있습니다. Interface Builder에서 거의 모든 유형의 제약 조건을 직접 작성할 수 있습니다(",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1"},"children":[{"type":"text","value":"Working with Constraints in Interface Builder","position":{"start":{"line":14,"column":96,"offset":557},"end":{"line":14,"column":141,"offset":602}}}],"position":{"start":{"line":14,"column":95,"offset":556},"end":{"line":14,"column":326,"offset":787}}},"children":"Working with Constraints in Interface Builder"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$f","category":"swift"},"language":"kr"}]," 참조). 또한 크기 클래스별 제약 조건을 지정할 수 있으며(",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1"},"children":[{"type":"text","value":"Debugging Auto Layout","position":{"start":{"line":14,"column":361,"offset":822},"end":{"line":14,"column":382,"offset":843}}}],"position":{"start":{"line":14,"column":360,"offset":821},"end":{"line":14,"column":540,"offset":1001}}},"children":"Debugging Auto Layout"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$10","category":"swift"},"language":"kr"}]," 참조) 스택 뷰와 같은 새로운 도구를 사용하여 런타임에 보기를 동적으로 추가하거나 제거할 수도 있습니다(",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19"},"children":[{"type":"text","value":"Dynamic Stack View","position":{"start":{"line":14,"column":600,"offset":1061},"end":{"line":14,"column":618,"offset":1079}}}],"position":{"start":{"line":14,"column":599,"offset":1060},"end":{"line":14,"column":785,"offset":1246}}},"children":"Dynamic Stack View"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$11","category":"swift"},"language":"kr"}]," 참조) 그러나 뷰 계층 구조에 대한 일부 동적 변경은 여전히 코드에서만 관리할 수 있습니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["프로그래밍 방식으로 제약 조건을 생성할 때 세 가지 선택 사항이 있습니다. layout anchors를 사용하거나 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint"},"children":[{"type":"text","value":"NSLayoutConstraint","position":{"start":{"line":16,"column":66,"offset":1365},"end":{"line":16,"column":84,"offset":1383}}}],"position":{"start":{"line":16,"column":65,"offset":1364},"end":{"line":16,"column":153,"offset":1452}}},"children":"NSLayoutConstraint"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$12","category":"swift"},"language":"kr"}]," 클래스를 사용하거나 Visual Format Language를 사용할 수 있습니다."]}],"\n",["$","h1",null,{"id":"2549b9d2","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"Layout Anchors"}],"\n",["$","hr","hr-2",{}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"NSLayoutAnchor 클래스는 제약 조건을 생성하기 위한 유창한 인터페이스를 제공합니다. 이 API를 사용하려면 제한하려는 항목의 앵커 속성에 액세스하세요. 예를 들어 뷰 컨트롤러의 상단 및 하단 레이아웃 가이드에는 topAnchor, bottomAnchor 및 heightAnchor 속성이 있습니다. 반면 뷰는 가장자리, 중심, 크기 및 기준선에 대한 앵커를 노출합니다."}],"\n",["$","blockquote",null,{"className":"bg-gray-100 p-[40px] md:my-[30px] my-[20px] rounded-[16px]","children":["\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"NOTE"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["iOS에서 뷰에는  ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide"},"children":[{"type":"text","value":"layoutMarginsGuide","position":{"start":{"line":26,"column":15,"offset":1761},"end":{"line":26,"column":33,"offset":1779}}}],"position":{"start":{"line":26,"column":14,"offset":1760},"end":{"line":26,"column":117,"offset":1863}}},"children":"layoutMarginsGuide"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$13","category":"swift"},"language":"kr"}]," 및  ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622644-readablecontentguide"},"children":[{"type":"text","value":"readableContentGuide","position":{"start":{"line":26,"column":122,"offset":1868},"end":{"line":26,"column":142,"offset":1888}}}],"position":{"start":{"line":26,"column":121,"offset":1867},"end":{"line":26,"column":228,"offset":1974}}},"children":"readableContentGuide"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$14","category":"swift"},"language":"kr"}]," 속성도 있습니다. 이러한 속성은 각각 뷰의 여백과 읽을 수 있는 콘텐츠 가이드를 나타내는 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/uilayoutguide","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/uilayoutguide"},"children":[{"type":"text","value":"UILayoutGuide","position":{"start":{"line":26,"column":280,"offset":2026},"end":{"line":26,"column":293,"offset":2039}}}],"position":{"start":{"line":26,"column":279,"offset":2025},"end":{"line":26,"column":357,"offset":2103}}},"children":"UILayoutGuide"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$15","category":"swift"},"language":"kr"}],"  개체를 노출합니다. 차례로 이러한 가이드는 가장자리, 중심 및 크기에 대한 앵커를 노출합니다.\n프로그래밍 방식으로 여백이나 읽을 수 있는 콘텐츠 가이드에 대한 제약 조건을 만들 때 이 가이드를 사용하세요."]}],"\n"]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"레이아웃 앵커를 사용하면 읽기 쉽고 압축된 형식으로 제약 조건을 만들 수 있습니다. 아래 코드 표시된 것처럼 다양한 유형의 제약 조건을 생성하기 위한 여러 메서드를 노출합니다."}],"\n",["$","pre","pre-0",{"children":["$","$L16",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"// Get the superview's layout\nlet margins = view.layoutMarginsGuide\n\n// Pin the leading edge of myView to the margin's leading edge\nmyView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true\n\n// Pin the trailing edge of myView to the margin's trailing edge\nmyView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true\n\n// Give myView a 1:2 aspect ratio\nmyView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true\n"}],"position":{"start":{"line":31,"column":1,"offset":2323},"end":{"line":43,"column":4,"offset":2823}}},"children":"// Get the superview's layout\nlet margins = view.layoutMarginsGuide\n\n// Pin the leading edge of myView to the margin's leading edge\nmyView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true\n\n// Pin the trailing edge of myView to the margin's trailing edge\nmyView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true\n\n// Give myView a 1:2 aspect ratio\nmyView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1"},"children":[{"type":"text","value":"Anatomy of a Constraint","position":{"start":{"line":45,"column":2,"offset":2826},"end":{"line":45,"column":25,"offset":2849}}}],"position":{"start":{"line":45,"column":1,"offset":2825},"end":{"line":45,"column":189,"offset":3013}}},"children":"Anatomy of a Constraint"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$17","category":"swift"},"language":"kr"}],"에서 설명한 것처럼 제약 조건은 단순히 선형 방정식입니다."]}],"\n",["$","$L18",null,{"className":"w-full h-auto md:my-[40px] my-[30px] rounded-[10px]","width":200,"height":200,"src":"/images/auto0301.jpg","alt":"image01"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"레이아웃 앵커에는 제약 조건을 만드는 여러 가지 방법이 있습니다. 각 방법에는 결과에 영향을 미치는 방정식 요소에 대한 매개변수만 포함됩니다. 따라서 다음 코드 줄에서:"}],"\n",["$","pre","pre-1",{"children":["$","$L16",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true\n"}],"position":{"start":{"line":51,"column":1,"offset":3177},"end":{"line":53,"column":4,"offset":3269}}},"children":"myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = true\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"기호는 방정식의 다음 부분에 해당합니다."}],"\n",["$","$L18",null,{"className":"w-full h-auto md:my-[40px] my-[30px] rounded-[10px]","width":200,"height":200,"src":"/images/auto0902.jpg","alt":"image02"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["레이아웃 앵커는 또한 추가적인 유형 안전성을 제공합니다. NSLayoutAnchor 클래스에는 제약 조건을 생성하기 위한 유형 정보 및 하위 클래스별 메서드를 추가하는 여러 하위 클래스가 있습니다. 이렇게 하면 잘못된 제약 조건이 실수로 생성되는 것을 방지할 수 있습니다. 예를 들어 다른 수평 앵커로만 수평 앵커(",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622520-leadinganchor"},"children":[{"type":"text","value":"leadingAnchor","position":{"start":{"line":59,"column":178,"offset":3506},"end":{"line":59,"column":191,"offset":3519}}}],"position":{"start":{"line":59,"column":177,"offset":3505},"end":{"line":59,"column":270,"offset":3598}}},"children":"leadingAnchor"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$19","category":"swift"},"language":"kr"}]," 또는 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/uiview/1622522-trailinganchor"},"children":[{"type":"text","value":"trailingAnchor","position":{"start":{"line":59,"column":275,"offset":3603},"end":{"line":59,"column":289,"offset":3617}}}],"position":{"start":{"line":59,"column":274,"offset":3602},"end":{"line":59,"column":369,"offset":3697}}},"children":"trailingAnchor"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1a","category":"swift"},"language":"kr"}],")를 제한할 수 있습니다. 마찬가지로 크기 제약 조건에 대해서만 승수를 제공할 수 있습니다."]}],"\n",["$","blockquote",null,{"className":"bg-gray-100 p-[40px] md:my-[30px] my-[20px] rounded-[16px]","children":["\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"NOTE"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["이러한 규칙은 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint"},"children":[{"type":"text","value":"NSLayoutConstraint","position":{"start":{"line":63,"column":12,"offset":3770},"end":{"line":63,"column":30,"offset":3788}}}],"position":{"start":{"line":63,"column":11,"offset":3769},"end":{"line":63,"column":99,"offset":3857}}},"children":"NSLayoutConstraint"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1b","category":"swift"},"language":"kr"}]," API에 의해 시행되지 않습니다. 대신 잘못된 제약 조건을 만들면 해당 제약 조건이 런타임에 예외를 발생시킵니다. 따라서 레이아웃 앵커는 런타임 오류를 컴파일 시간 오류로 변환하는 데 도움이 됩니다."]}],"\n"]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["자세한 내용은  ",["$","em",null,{"className":"bg-[rgba(238,220,130,0.4)] font-normal not-italic p-[2px] rounded-[2px]","children":[["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/appkit/nslayoutanchor","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/appkit/nslayoutanchor"},"children":[{"type":"text","value":"NSLayoutAnchor Class Reference","position":{"start":{"line":65,"column":12,"offset":3982},"end":{"line":65,"column":42,"offset":4012}}}],"position":{"start":{"line":65,"column":11,"offset":3981},"end":{"line":65,"column":108,"offset":4078}}},"children":"NSLayoutAnchor Class Reference"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1c","category":"swift"},"language":"kr"}],"를"]}]," 참조하세요."]}],"\n",["$","h1",null,{"id":"0d367e9f","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"NSLayoutConstraint Class"}],"\n",["$","hr","hr-3",{}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["또한 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint"},"children":[{"type":"text","value":"NSLayoutConstraint","position":{"start":{"line":71,"column":5,"offset":4126},"end":{"line":71,"column":23,"offset":4144}}}],"position":{"start":{"line":71,"column":4,"offset":4125},"end":{"line":71,"column":92,"offset":4213}}},"children":"NSLayoutConstraint"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1d","category":"swift"},"language":"kr"}]," 클래스의 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init"},"children":[{"type":"text","value":"constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:","position":{"start":{"line":71,"column":99,"offset":4220},"end":{"line":71,"column":175,"offset":4296}}}],"position":{"start":{"line":71,"column":98,"offset":4219},"end":{"line":71,"column":258,"offset":4379}}},"children":"constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1e","category":"swift"},"language":"kr"}]," 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2"},"children":[{"type":"text","value":"The constraint equation","position":{"start":{"line":71,"column":351,"offset":4472},"end":{"line":71,"column":374,"offset":4495}}}],"position":{"start":{"line":71,"column":350,"offset":4471},"end":{"line":71,"column":538,"offset":4659}}},"children":"The constraint equation"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$1f","category":"swift"},"language":"kr"}]," 참조)."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"또한 NSLayoutConstraint 클래스의 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 편리한 메서드를 사용하여 제약 조건을 직접 생성할 수도 있습니다. 이 방법은 명시적으로 구속 방정식을 코드로 변환합니다. 각 매개변수는 방정식의 일부에 해당합니다(제약 방정식 참조)."}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"레이아웃 앵커 API에서 사용하는 접근 방식과 달리 레이아웃에 영향을 주지 않더라도 매개변수마다 값을 지정해야 합니다. 최종 결과는 일반적으로 읽기 어려운 상당한 양의 상용구 코드입니다. 예를 들어 아래 코드의 코드는 목록 위에서 설명한 코드와 기능적으로 동일합니다."}],"\n",["$","pre","pre-2",{"children":["$","$L16",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true\n\nNSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true\n\nNSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true\n"}],"position":{"start":{"line":77,"column":1,"offset":5025},"end":{"line":83,"column":4,"offset":5518}}},"children":"NSLayoutConstraint(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: 1.0, constant: 0.0).isActive = true\n\nNSLayoutConstraint(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: 1.0, constant: 0.0).isActive = true\n\nNSLayoutConstraint(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: 2.0, constant:0.0).isActive = true\n"}}]}],"\n",["$","blockquote",null,{"className":"bg-gray-100 p-[40px] md:my-[30px] my-[20px] rounded-[16px]","children":["\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"NOTE"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["레이아웃 앵커 API와 달리 편의 메서드는 특정 제약 조건의 중요한 기능을 강조 표시하지 않습니다. 결과적으로 코드를 스캔할 때 중요한 세부 정보를 놓치기 쉽습니다. 또한 컴파일러는 제약 조건의 정적 분석을 수행하지 않습니다. 유효하지 않은 제약 조건을 자유롭게 생성할 수 있습니다. 그런 다음 이러한 제약 조건은 런타임에 예외를 발생시킵니다. 따라서 iOS 8 또는 OS X v10.10 이하를 지원해야 하는 경우가 아니면 코드를 최신 레이아웃 앵커 API로 마이그레이션하는 것이 좋습니다.\n자세한 내용은 *",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint"},"children":[{"type":"text","value":"NSLayoutConstraint Class Reference","position":{"start":{"line":88,"column":13,"offset":5819},"end":{"line":88,"column":47,"offset":5853}}}],"position":{"start":{"line":88,"column":12,"offset":5818},"end":{"line":88,"column":116,"offset":5922}}},"children":"NSLayoutConstraint Class Reference"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$20","category":"swift"},"language":"kr"}],"*를 참조하십시오."]}],"\n"]}],"\n",["$","h1",null,{"id":"157ed7dc","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"Visual Format Language"}],"\n",["$","hr","hr-4",{}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","strong",null,{"className":"font-black","children":"Visual Format Language"}],"를 사용하면 문자열과 같은 ASCII 아트를 사용하여 제약 조건을 정의할 수 있습니다. 이는 제약 조건을 시각적으로 설명하는 표현을 제공합니다. Visual Formatting Language에는 다음과 같은 장점과 단점이 있습니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["오토 레이아웃은 ",["$","strong",null,{"className":"font-black","children":"Visual Format Language"}],"를 사용하여 콘솔에 제약 조건을 인쇄합니다. 이러한 이유로 디버깅 메시지는 제약 조건을 생성하는 데 사용되는 코드와 매우 유사합니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","strong",null,{"className":"font-black","children":"Visual Format Language"}],"를 사용하면 매우 간결한 표현을 사용하여 한 번에 여러 제약 조건을 만들 수 있습니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","strong",null,{"className":"font-black","children":"Visual Format Language"}],"를 사용하면 유효한 제약 조건만 만들 수 있습니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"표기법은 완전성보다 좋은 시각화를 강조합니다. 따라서 시각적 형식 언어를 사용하여 일부 제약 조건(예: 종횡비)을 만들 수 없습니다."}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"컴파일러는 어떤 식으로든 문자열의 유효성을 검사하지 않습니다. 런타임 테스트를 통해서만 실수를 발견할 수 있습니다."}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"위에서 설명했던 코드들을 Visual Format Language를 사용하여 다시 작성해보았습니다."}],"\n",["$","pre","pre-3",{"children":["$","$L16",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"let views = [\"myView\" : myView]\nlet formatString = \"|-[myView]-|\"\n\nlet constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)\n\nNSLayoutConstraint.activate(constraints)\n"}],"position":{"start":{"line":108,"column":1,"offset":6565},"end":{"line":115,"column":4,"offset":6818}}},"children":"let views = [\"myView\" : myView]\nlet formatString = \"|-[myView]-|\"\n\nlet constraints = NSLayoutConstraint.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: nil, views: views)\n\nNSLayoutConstraint.activate(constraints)\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["이 예에서는 leading 및 trailing 제약 조건을 모두 만들고 활성화합니다. ",["$","strong",null,{"className":"font-black","children":"Visual Format Language"}],"는 기본 간격을 사용할 때 항상 슈퍼뷰의 여백에 0포인트 제약 조건을 생성하므로 이러한 제약 조건은 이전 예제와 동일합니다. 그러나 위코드는 종횡비 제약을 만들 수 없습니다."]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"한 줄에 여러 항목이 있는 더 복잡한 보기를 만드는 경우 시각적 형식 언어는 세로 정렬과 가로 간격을 모두 지정합니다. 작성된 것처럼 \"Align All Top\" 옵션은 레이아웃에 영향을 미치지 않습니다. 예제에는 하나의 뷰만 있기 때문입니다(슈퍼뷰는 포함하지 않음)."}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"시각적 형식 언어를 사용하여 제약 조건을 만들려면 다음을 수행하십시오."}],"\n",["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":"뷰 Dictionary를 만듭니다. 이 Dictionary에는 값으로 키 및 뷰 객체(또는 레이아웃 가이드와 같이 자동 레이아웃에서 제한될 수 있는 다른 항목)에 대한 문자열이 있어야 합니다. 형식 문자열에서 보기를 식별하려면 키를 사용하십시오."}],"\n"]}],"\n",["$","blockquote",null,{"className":"bg-gray-100 p-[40px] md:my-[30px] my-[20px] rounded-[16px]","children":["\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"NOTE"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["Objective-C를 사용할 때 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nsdictionaryofvariablebindings"},"children":[{"type":"text","value":"NSDictionaryOfVariableBindings","position":{"start":{"line":127,"column":23,"offset":7359},"end":{"line":127,"column":53,"offset":7389}}}],"position":{"start":{"line":127,"column":22,"offset":7358},"end":{"line":127,"column":134,"offset":7470}}},"children":"NSDictionaryOfVariableBindings"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$21","category":"swift"},"language":"kr"}]," 매크로를 사용하여 뷰 Dictionary를 만듭니다. Swift에서는 사전을 직접 만들어야 합니다."]}],"\n"]}],"\n",["$","ol","ol-1",{"start":2,"children":["\n",["$","li","li-0",{"children":"(Optional) metrics dictionary을 작성하십시오. 이 dictionary에는 키에 대한 문자열과 값에 대한 NSNumber 객체가 있어야 합니다. 키를 사용하여 형식 문자열에서 상수 값을 나타냅니다."}],"\n",["$","li","li-1",{"children":"항목의 단일 행 또는 열을 배치하여 형식 문자열을 만듭니다."}],"\n",["$","li","li-2",{"children":[["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/uikit/nslayoutconstraint"},"children":[{"type":"text","value":"NSLayoutConstraint","position":{"start":{"line":131,"column":5,"offset":7695},"end":{"line":131,"column":23,"offset":7713}}}],"position":{"start":{"line":131,"column":4,"offset":7694},"end":{"line":131,"column":92,"offset":7782}}},"children":"NSLayoutConstraint"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$22","category":"swift"},"language":"kr"}]," 클래스의 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526944-constraints"},"children":[{"type":"text","value":"constraintsWithVisualFormat:options:metrics:views:","position":{"start":{"line":131,"column":99,"offset":7789},"end":{"line":131,"column":149,"offset":7839}}}],"position":{"start":{"line":131,"column":98,"offset":7788},"end":{"line":131,"column":239,"offset":7929}}},"children":"constraintsWithVisualFormat:options:metrics:views:"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$23","category":"swift"},"language":"kr"}]," 메소드를 호출합니다. 이 메서드는 모든 제약 조건을 포함하는 배열을 반환합니다."]}],"\n",["$","li","li-3",{"children":["NSLayoutConstraint 클래스의 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526955-activate"},"children":[{"type":"text","value":"activateConstraints:","position":{"start":{"line":132,"column":29,"offset":8003},"end":{"line":132,"column":49,"offset":8023}}}],"position":{"start":{"line":132,"column":28,"offset":8002},"end":{"line":132,"column":136,"offset":8110}}},"children":"activateConstraints:"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$24","category":"swift"},"language":"kr"}]," 메소드를 호출하여 제약 조건을 활성화합니다."]}],"\n"]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["자세한 내용은 ",["$","$Ld",null,{"props":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1","node":{"type":"element","tagName":"a","properties":{"href":"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1"},"children":[{"type":"text","value":"Visual Format Language","position":{"start":{"line":134,"column":10,"offset":8146},"end":{"line":134,"column":32,"offset":8168}}}],"position":{"start":{"line":134,"column":9,"offset":8145},"end":{"line":134,"column":197,"offset":8333}}},"children":"Visual Format Language"},"post":{"title":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","description":"apple 공식 문서인 Auto Layout Guide 중 Programmatically Creating Constraints - Advanced Auto Layout Chapter를 번역한 글입니다.","date":"2023-05-04T23:55:40.322Z","tags":[{"name":"swift","path":"/tags/swift","id":"swift"},{"name":"auth layout","path":"/tags/auth-layout","id":"auth-layout"},{"name":"document","path":"/tags/document","id":"document"},{"name":"번역","path":"/tags/번역","id":"번역"},{"name":"UIKit","path":"/tags/uikit","id":"uikit"}],"author":"마고유","banner":"/images/auto0301.jpg","project":"swift auto layout","readMin":"10.0","totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"slug":"programmatically+creating+constraints","content":"$25","category":"swift"},"language":"kr"}]," 부록을 참조하십시오."]}]]}]}],["$","$L26",null,{}]]}],["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","$L27",null,{"articleTitle":"[번역] Programmatically Creating Constraints - Advanced Auto Layout","toc":[{"tagName":"h1","title":"개요","id":"476966c5"},{"tagName":"h1","title":"Programmatically Creating Constraints","id":"53c7994a"},{"tagName":"h1","title":"Layout Anchors","id":"2549b9d2"},{"tagName":"h1","title":"NSLayoutConstraint Class","id":"0d367e9f"},{"tagName":"h1","title":"Visual Format Language","id":"157ed7dc"}],"language":"kr"}]}]]}]]
8:null
