1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/98e4530578c425d7.css",{"as":"style"}]
0:["BTzIZmIeYXT3BlsSUt3SU",[[["",{"children":["algorithm",{"children":[["slug","%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B5%EC%8B%AC-59f7692e","d"],{"children":["__PAGE__?{\"slug\":\"위상-정렬-이해하기-그래프-알고리즘의-핵심-59f7692e\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/98e4530578c425d7.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":42879,"chunks":["185:static/chunks/app/layout-b198f10c98e34978.js"],"name":"GoogleAnalytics","async":false}
6:I{"id":47767,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
7:I{"id":57920,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
3:[null,["$","html",null,{"lang":"ko","children":[["$","$L5",null,{}],["$","body",null,{"className":"__className_aaf875","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","algorithm","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","algorithm","children",["slug","%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B5%EC%8B%AC-59f7692e","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"위상-정렬-이해하기-그래프-알고리즘의-핵심-59f7692e\"}"},"styles":[]}],"segment":["slug","%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B5%EC%8B%AC-59f7692e","d"]},"styles":[]}],"segment":"algorithm"},"styles":[]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"위상 정렬 이해하기: 그래프 알고리즘의 핵심 | 마고자비 블로그"}],["$","meta","2",{"name":"description","content":"위상 정렬은 그래프 알고리즘 중 하나로, 유향 그래프의 노드를 순서대로 정렬하는 방법입니다. 본문에서는 위상 정렬의 개념, 작동 원리, 구현 방법 및 실용 예제를 다룹니다. 이를 통해 그래프 알고리즘을 더 깊이 이해할 수 있습니다."}],["$","meta","3",{"name":"keywords","content":"알고리즘,그래프,위상 정렬,데이터 구조"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"}],["$","link","5",{"rel":"canonical","href":"https://magomercy.com/algorithm/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B5%EC%8B%AC-59f7692e"}],["$","meta","6",{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta","7",{"name":"apple-mobile-web-app-title","content":"위상 정렬 이해하기: 그래프 알고리즘의 핵심 | 마고자비 블로그"}],["$","meta","8",{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta","9",{"property":"og:title","content":"위상 정렬 이해하기: 그래프 알고리즘의 핵심 | 마고자비 블로그"}],["$","meta","10",{"property":"og:description","content":"위상 정렬은 그래프 알고리즘 중 하나로, 유향 그래프의 노드를 순서대로 정렬하는 방법입니다. 본문에서는 위상 정렬의 개념, 작동 원리, 구현 방법 및 실용 예제를 다룹니다. 이를 통해 그래프 알고리즘을 더 깊이 이해할 수 있습니다."}],["$","meta","11",{"property":"og:url","content":"https://magomercy.com/algorithm/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B5%EC%8B%AC-59f7692e"}],["$","meta","12",{"property":"og:site_name","content":"마고자비 블로그 | 마구잡이로 하고 싶은 것을 합니다."}],["$","meta","13",{"property":"og:locale","content":"kr"}],["$","meta","14",{"property":"og:image","content":"https://magomercy.com/images/defaultBanner1.jpg"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary"}],["$","meta","17",{"name":"twitter:creator","content":"마고자비 블로그"}],["$","meta","18",{"name":"twitter:title","content":"위상 정렬 이해하기: 그래프 알고리즘의 핵심 | 마고자비 블로그"}],["$","meta","19",{"name":"twitter:description","content":"위상 정렬은 그래프 알고리즘 중 하나로, 유향 그래프의 노드를 순서대로 정렬하는 방법입니다. 본문에서는 위상 정렬의 개념, 작동 원리, 구현 방법 및 실용 예제를 다룹니다. 이를 통해 그래프 알고리즘을 더 깊이 이해할 수 있습니다."}],["$","meta","20",{"name":"twitter:image","content":"https://magomercy.com/images/defaultBanner1.jpg"}],["$","link","21",{"rel":"icon","href":"https://magomercy.com/favicon32.png"}],["$","link","22",{"rel":"apple-touch-icon","href":"https://magomercy.com/favicon32.png"}],["$","meta","23",{"name":"next-size-adjust"}]]
a:I{"id":22873,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
b:I{"id":84423,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
c:I{"id":2346,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
d:I{"id":67490,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"MarkDownCode","async":false}
e:I{"id":87272,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
f:I{"id":55026,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
9:[["$","$La",null,{"language":"kr","screenType":"ARTICLE_DETAIL"}],["$","section",null,{"className":"flex fixed top-0 left-0 w-full  md:h-[600px] h-[300px] justify-center","style":{"backgroundImage":"url(/images/defaultBanner1.jpg)","backgroundPosition":"center","backgroundSize":"contain","backgroundRepeat":"no-repeat"},"children":[["$","div",null,{"className":"w-full md:h-[600px] h-[300px]  bg-[#171E24] bg-opacity-[0.35] absolute top-0 left-0"}],["$","div",null,{"className":"hidden md:flex flex-col justify-end w-[100%] md:w-[700px] px-[20px] pb-[100px]","children":["$","h1",null,{"className":"font-semibold text-[40px] text-gray-100 text-shadow-default z-40","children":"위상 정렬 이해하기: 그래프 알고리즘의 핵심"}]}]]}],["$","main",null,{"className":"flex flex-row justify-center md:py-[120px] py-[60px] bg-white md:mt-[600px] mt-[300px] relative z-30 ","children":[["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","div",null,{"className":"toc sticky top-[90px] flex flex-col","children":["$","$Lb",null,{}]}]}],["$","article",null,{"className":"flex flex-col w-full md:w-[600px] px-[20px] md:px-[0px] gap-[40px]","children":[["$","div",null,{"className":"md:hidden border-b-[0.6px] pb-[40px] border-gray-200","children":["$","h1",null,{"className":"text-[28px] font-bold leading-[150%]","children":"위상 정렬 이해하기: 그래프 알고리즘의 핵심"}]}],["$","div",null,{"className":"flex flex-col","children":[["$","$Lc",null,{}],["$","div",null,{"children":["작성일 : ",["$","time",null,{"children":"2024-06-17"}]]}]]}],["$","div",null,{"children":["$","div",null,{"className":"md-to-html","children":[["$","h1",null,{"id":"c6de604d","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"위상 정렬 이해하기: 그래프 알고리즘의 핵심"}],"\n",["$","h2",null,{"id":"c5ba82fc","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"위상 정렬이란?"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"위상 정렬(Topological Sorting)은 방향성이 있는 비순환 그래프(Directed Acyclic Graph, DAG)의 노드를 순서대로 나열하는 작업을 의미합니다. 위상 정렬은 노드 A에서 노드 B로 가는 경로가 있는 경우, 나열된 순서에서 항상 A가 B의 앞에 오도록 합니다. 일상생활의 많은 문제들이 이러한 형식으로 표현될 수 있기 때문에, 위상 정렬은 다양한 응용 분야에서 중요합니다."}],"\n",["$","h2",null,{"id":"950e9a28","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"위상 정렬의 작동 원리"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["위상 정렬은 주로 두 가지 방법으로 구현됩니다: ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DFS(Depth-First Search)","position":{"start":{"line":8,"column":28,"offset":311},"end":{"line":8,"column":53,"offset":336}}}],"position":{"start":{"line":8,"column":28,"offset":311},"end":{"line":8,"column":53,"offset":336}}},"children":"DFS(Depth-First Search)"}}]," 기반 방법과 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Kahn's Algorithm","position":{"start":{"line":8,"column":61,"offset":344},"end":{"line":8,"column":79,"offset":362}}}],"position":{"start":{"line":8,"column":61,"offset":344},"end":{"line":8,"column":79,"offset":362}}},"children":"Kahn's Algorithm"}}],"입니다. 이 두 방법은 위상 정렬을 구현하는 데 있어 각각의 특징과 장단점을 가지고 있습니다."]}],"\n",["$","h3",null,{"id":"4034a50d","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"DFS 기반 방법"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"DFS 기반 방법은 재귀를 사용하여 그래프의 각 노드를 탐색합니다. 노드를 방문하고, 모든 인접한 노드를 방문한 후에 해당 노드를 스택에 저장합니다. 모든 노드를 탐색한 후, 스택을 역순으로 꺼내면 위상 정렬 결과가 됩니다. 아래는 기본적인 구현 코드입니다:"}],"\n",["$","pre","pre-0",{"children":["$","$Ld",null,{"props":{"className":"language-python","node":{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"# Python3 DFS-based topological sort\nfrom collections import defaultdict\n\n# 그래프 클래스 정의\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def topologicalSortUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.topologicalSortUtil(i, visited, stack)\n        stack.insert(0, v)\n\n    def topologicalSort(self):\n        visited = [False] * self.V\n        stack = []\n        for i in range(self.V):\n            if not visited[i]:\n                self.topologicalSortUtil(i, visited, stack)\n        print(stack)\n\n# 예제 사용법\nif __name__ == '__main__':\n    g = Graph(6)\n    g.addEdge(5, 2)\n    g.addEdge(5, 0)\n    g.addEdge(4, 0)\n    g.addEdge(4, 1)\n    g.addEdge(2, 3)\n    g.addEdge(3, 1)\n\n    print(\"Topological Sort of the given graph:\")\n    g.topologicalSort()\n"}],"position":{"start":{"line":13,"column":1,"offset":576},"end":{"line":53,"column":4,"offset":1560}}},"children":"# Python3 DFS-based topological sort\nfrom collections import defaultdict\n\n# 그래프 클래스 정의\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def topologicalSortUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.topologicalSortUtil(i, visited, stack)\n        stack.insert(0, v)\n\n    def topologicalSort(self):\n        visited = [False] * self.V\n        stack = []\n        for i in range(self.V):\n            if not visited[i]:\n                self.topologicalSortUtil(i, visited, stack)\n        print(stack)\n\n# 예제 사용법\nif __name__ == '__main__':\n    g = Graph(6)\n    g.addEdge(5, 2)\n    g.addEdge(5, 0)\n    g.addEdge(4, 0)\n    g.addEdge(4, 1)\n    g.addEdge(2, 3)\n    g.addEdge(3, 1)\n\n    print(\"Topological Sort of the given graph:\")\n    g.topologicalSort()\n"}}]}],"\n",["$","h3",null,{"id":"120deee8","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"Kahn's Algorithm"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Kahn's Algorithm은 BFS(Breadth-First Search)를 기반으로 한 방법입니다. 모든 노드의 진입 차수(In-degree)를 계산합니다. 진입 차수가 0인 노드를 큐에 넣고, 큐에서 노드를 제거하면서 인접한 노드의 진입 차수를 감소시킵니다. 다시 진입 차수가 0이 된 노드를 큐에 추가하는 과정을 반복합니다. 이를 통해 위상 정렬을 수행합니다."}],"\n",["$","pre","pre-1",{"children":["$","$Ld",null,{"props":{"className":"language-python","node":{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"# Python3 Kahn's Algorithm for topological sorting\nfrom collections import deque, defaultdict\n\n# 위상 정렬 알고리즘\ndef topologicalSort(vertices, edges):\n    in_degree = {i: 0 for i in range(vertices)}\n    graph = defaultdict(list)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    queue = deque([i for i in range(vertices) if in_degree[i] == 0])\n    topo_order = []\n\n    while queue:\n        vertex = queue.popleft()\n        topo_order.append(vertex)\n\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) == vertices:\n        return topo_order\n    else:\n        return []\n\n# 예제 사용법\nif __name__ == '__main__':\n    vertices = 6\n    edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]\n    print(\"Topological Sort of the given graph:\", topologicalSort(vertices, edges))\n"}],"position":{"start":{"line":58,"column":1,"offset":1791},"end":{"line":93,"column":4,"offset":2727}}},"children":"# Python3 Kahn's Algorithm for topological sorting\nfrom collections import deque, defaultdict\n\n# 위상 정렬 알고리즘\ndef topologicalSort(vertices, edges):\n    in_degree = {i: 0 for i in range(vertices)}\n    graph = defaultdict(list)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    queue = deque([i for i in range(vertices) if in_degree[i] == 0])\n    topo_order = []\n\n    while queue:\n        vertex = queue.popleft()\n        topo_order.append(vertex)\n\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) == vertices:\n        return topo_order\n    else:\n        return []\n\n# 예제 사용법\nif __name__ == '__main__':\n    vertices = 6\n    edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]\n    print(\"Topological Sort of the given graph:\", topologicalSort(vertices, edges))\n"}}]}],"\n",["$","h2",null,{"id":"90b18224","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"위상 정렬의 실용 예제"}],"\n",["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong",null,{"className":"font-black","children":"프로젝트 일정 관리"}],": 프로젝트 내 작업들이 의존성을 가지는 경우 위상 정렬을 사용해서 작업 순서를 결정할 수 있습니다.",["$","br","br-0",{}]]}],"\n",["$","li","li-1",{"children":[["$","strong",null,{"className":"font-black","children":"컴파일러 최적화"}],": 컴파일러가 코드 모듈을 컴파일하는 순서를 결정할 때, 모듈 간의 의존성을 고려하여 위상 정렬을 수행합니다.",["$","br","br-0",{}]]}],"\n",["$","li","li-2",{"children":[["$","strong",null,{"className":"font-black","children":"수강 과목 선택 순서"}],": 학생이 수강해야 하는 과목들이 선수 조건을 가지는 경우 위상 정렬을 통해 과목들의 수강 순서를 정합니다.",["$","br","br-0",{}]]}],"\n",["$","li","li-3",{"children":[["$","strong",null,{"className":"font-black","children":"소프트웨어 빌드 시스템"}],": 소프트웨어의 개별 구성 요소들이 빌드되기 위한 순서를 위상 정렬을 사용해서 결정합니다."]}],"\n"]}],"\n",["$","h2",null,{"id":"5b12bcf2","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"결론"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"위상 정렬은 다양한 분야에서 문제 해결을 위한 강력한 도구입니다. DFS와 Kahn's Algorithm 두 가지 방법을 통해 위상 정렬을 구현할 수 있으며, 이를 통해 복잡한 의존성 문제를 체계적으로 해결할 수 있습니다. 위상 정렬을 통해 그래프 이론의 기본 개념을 이해하고 실제 문제에 적용함으로써 문제 해결 능력을 향상시킬 수 있습니다."}]]}]}],["$","$Le",null,{}]]}],["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","$Lf",null,{"articleTitle":"위상 정렬 이해하기: 그래프 알고리즘의 핵심","toc":[{"tagName":"h1","title":"위상 정렬 이해하기: 그래프 알고리즘의 핵심","id":"c6de604d"},{"tagName":"h2","title":"위상 정렬이란?","id":"c5ba82fc"},{"tagName":"h2","title":"위상 정렬의 작동 원리","id":"950e9a28"},{"tagName":"h3","title":"DFS 기반 방법","id":"4034a50d"},{"tagName":"h3","title":"Kahn's Algorithm","id":"120deee8"},{"tagName":"h2","title":"위상 정렬의 실용 예제","id":"90b18224"},{"tagName":"h2","title":"결론","id":"5b12bcf2"}],"language":"kr"}]}]]}]]
8:null
