1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/98e4530578c425d7.css",{"as":"style"}]
0:["BTzIZmIeYXT3BlsSUt3SU",[[["",{"children":["swift",{"children":[["slug","%EA%B3%A0%EA%B8%89-Swift-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95-53902c66","d"],{"children":["__PAGE__?{\"slug\":\"고급-Swift-프로토콜과-연관-타입-활용하기-제네릭-프로토콜과-연관-타입을-이용한-유연한-설계-방법-53902c66\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/98e4530578c425d7.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":42879,"chunks":["185:static/chunks/app/layout-b198f10c98e34978.js"],"name":"GoogleAnalytics","async":false}
6:I{"id":47767,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
7:I{"id":57920,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
3:[null,["$","html",null,{"lang":"ko","children":[["$","$L5",null,{}],["$","body",null,{"className":"__className_aaf875","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","swift","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","swift","children",["slug","%EA%B3%A0%EA%B8%89-Swift-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95-53902c66","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"고급-Swift-프로토콜과-연관-타입-활용하기-제네릭-프로토콜과-연관-타입을-이용한-유연한-설계-방법-53902c66\"}"},"styles":[]}],"segment":["slug","%EA%B3%A0%EA%B8%89-Swift-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95-53902c66","d"]},"styles":[]}],"segment":"swift"},"styles":[]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법. | 마고자비 블로그"}],["$","meta","2",{"name":"description","content":"이 글에서는 Swift 프로그래밍 언어에서 고급 프로토콜 및 연관 타입을 활용하는 방법을 다룹니다. 제네릭 프로토콜과 연관 타입을 적극적으로 이용해 유연하고 확장 가능한 코드 설계를 구현하는 방법을 상세히 설명합니다."}],["$","meta","3",{"name":"keywords","content":"Swift,프로토콜,제네릭,연관 타입"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"}],["$","link","5",{"rel":"canonical","href":"https://magomercy.com/swift/%EA%B3%A0%EA%B8%89-Swift-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95-53902c66"}],["$","meta","6",{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta","7",{"name":"apple-mobile-web-app-title","content":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법. | 마고자비 블로그"}],["$","meta","8",{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta","9",{"property":"og:title","content":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법. | 마고자비 블로그"}],["$","meta","10",{"property":"og:description","content":"이 글에서는 Swift 프로그래밍 언어에서 고급 프로토콜 및 연관 타입을 활용하는 방법을 다룹니다. 제네릭 프로토콜과 연관 타입을 적극적으로 이용해 유연하고 확장 가능한 코드 설계를 구현하는 방법을 상세히 설명합니다."}],["$","meta","11",{"property":"og:url","content":"https://magomercy.com/swift/%EA%B3%A0%EA%B8%89-Swift-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%EC%97%B0%EA%B4%80-%ED%83%80%EC%9E%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95-53902c66"}],["$","meta","12",{"property":"og:site_name","content":"마고자비 블로그 | 마구잡이로 하고 싶은 것을 합니다."}],["$","meta","13",{"property":"og:locale","content":"kr"}],["$","meta","14",{"property":"og:image","content":"https://magomercy.com/images/swiftBanner1.jpg"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary"}],["$","meta","17",{"name":"twitter:creator","content":"마고자비 블로그"}],["$","meta","18",{"name":"twitter:title","content":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법. | 마고자비 블로그"}],["$","meta","19",{"name":"twitter:description","content":"이 글에서는 Swift 프로그래밍 언어에서 고급 프로토콜 및 연관 타입을 활용하는 방법을 다룹니다. 제네릭 프로토콜과 연관 타입을 적극적으로 이용해 유연하고 확장 가능한 코드 설계를 구현하는 방법을 상세히 설명합니다."}],["$","meta","20",{"name":"twitter:image","content":"https://magomercy.com/images/swiftBanner1.jpg"}],["$","link","21",{"rel":"icon","href":"https://magomercy.com/favicon32.png"}],["$","link","22",{"rel":"apple-touch-icon","href":"https://magomercy.com/favicon32.png"}],["$","meta","23",{"name":"next-size-adjust"}]]
a:I{"id":22873,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
b:I{"id":84423,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
c:I{"id":2346,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
d:I{"id":67490,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"MarkDownCode","async":false}
e:I{"id":87272,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
f:I{"id":55026,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","288:static/chunks/app/swift/[slug]/page-4841b882b9c15aba.js"],"name":"","async":false}
9:[["$","$La",null,{"language":"kr","screenType":"ARTICLE_DETAIL"}],["$","section",null,{"className":"flex fixed top-0 left-0 w-full  md:h-[600px] h-[300px] justify-center","style":{"backgroundImage":"url(/images/swiftBanner1.jpg)","backgroundPosition":"center","backgroundSize":"contain","backgroundRepeat":"no-repeat"},"children":[["$","div",null,{"className":"w-full md:h-[600px] h-[300px]  bg-[#171E24] bg-opacity-[0.35] absolute top-0 left-0"}],["$","div",null,{"className":"hidden md:flex flex-col justify-end w-[100%] md:w-[700px] px-[20px] pb-[100px]","children":["$","h1",null,{"className":"font-semibold text-[40px] text-gray-100 text-shadow-default z-40","children":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법."}]}]]}],["$","main",null,{"className":"flex flex-row justify-center md:py-[120px] py-[60px] bg-white md:mt-[600px] mt-[300px] relative z-30 ","children":[["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","div",null,{"className":"toc sticky top-[90px] flex flex-col","children":["$","$Lb",null,{}]}]}],["$","article",null,{"className":"flex flex-col w-full md:w-[600px] px-[20px] md:px-[0px] gap-[40px]","children":[["$","div",null,{"className":"md:hidden border-b-[0.6px] pb-[40px] border-gray-200","children":["$","h1",null,{"className":"text-[28px] font-bold leading-[150%]","children":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법."}]}],["$","div",null,{"className":"flex flex-col","children":[["$","$Lc",null,{}],["$","div",null,{"children":["작성일 : ",["$","time",null,{"children":"2024-07-02"}]]}]]}],["$","div",null,{"children":["$","div",null,{"className":"md-to-html","children":[["$","h1",null,{"id":"f26746aa","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Swift에서 프로토콜과 연관 타입을 활용하는 것은 코드의 유연성과 재사용성을 극대화하는 데 매우 유용합니다. 특히 제네릭 프로토콜과 연관 타입을 잘 사용하면 코드의 의도를 명확히 나타내면서도 확장 가능한 구조를 설계할 수 있습니다. 이 글에서는 Swift의 고급 기능들을 심도 있게 알아보고, 구체적인 예제를 통해 실용적인 활용 방법을 배워보겠습니다."}],"\n",["$","h2",null,{"id":"30c1b085","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"기본 프로토콜과 연관 타입의 이해"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"먼저 프로토콜(protocol)과 연관 타입(associated type)에 대해 간단히 살펴보겠습니다. 프로토콜은 특정 기능을 구현하기 위해 필요한 메서드, 프로퍼티, 기타 요구사항을 지정하는 일종의 청사진입니다. 반면, 연관 타입은 프로토콜의 일부분으로, 프로토콜이 사용될 때까지 해당 타입이 구체적으로 정의되지 않습니다. 예를 들어보겠습니다."}],"\n",["$","pre","pre-0",{"children":["$","$Ld",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"protocol Container {\n    associatedtype Item\n    mutating func append(_ item: Item)\n    var count: Int { get }\n    subscript(i: Int) -> Item { get }\n}\n"}],"position":{"start":{"line":10,"column":1,"offset":480},"end":{"line":17,"column":4,"offset":643}}},"children":"protocol Container {\n    associatedtype Item\n    mutating func append(_ item: Item)\n    var count: Int { get }\n    subscript(i: Int) -> Item { get }\n}\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["위의 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Container","position":{"start":{"line":19,"column":4,"offset":648},"end":{"line":19,"column":15,"offset":659}}}],"position":{"start":{"line":19,"column":4,"offset":648},"end":{"line":19,"column":15,"offset":659}}},"children":"Container"}}]," 프로토콜은 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Item","position":{"start":{"line":19,"column":22,"offset":666},"end":{"line":19,"column":28,"offset":672}}}],"position":{"start":{"line":19,"column":22,"offset":666},"end":{"line":19,"column":28,"offset":672}}},"children":"Item"}}],"이라는 연관 타입을 사용합니다. 이 타입은 프로토콜을 채택한 특정 타입이 정의될 때 구체화됩니다."]}],"\n",["$","h2",null,{"id":"5bef690d","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"제네릭 프로토콜의 실용적 활용"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["제네릭 프로토콜을 이용하면 프로토콜의 유연성을 크게 높일 수 있습니다. 이를 위해 제네릭을 사용하여 특정 타입 제약을 추가할 수 있습니다. 예를 들어, 아래와 같이 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Container","position":{"start":{"line":23,"column":93,"offset":841},"end":{"line":23,"column":104,"offset":852}}}],"position":{"start":{"line":23,"column":93,"offset":841},"end":{"line":23,"column":104,"offset":852}}},"children":"Container"}}]," 프로토콜을 구현하는 여러 타입을 생각해볼 수 있습니다."]}],"\n",["$","pre","pre-1",{"children":["$","$Ld",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"struct IntStack: Container {\n    // 연관 타입으로 Int를 사용\n    var items: [Int] = []\n    mutating func append(_ item: Int) {\n        items.append(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Int {\n        return items[i]\n    }\n}\n\nstruct GenericStack<Element>: Container {\n    // 연관 타입으로 제네릭 타입을 사용\n    var items: [Element] = []\n    mutating func append(_ item: Element) {\n        items.append(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n"}],"position":{"start":{"line":25,"column":1,"offset":885},"end":{"line":53,"column":4,"offset":1462}}},"children":"struct IntStack: Container {\n    // 연관 타입으로 Int를 사용\n    var items: [Int] = []\n    mutating func append(_ item: Int) {\n        items.append(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Int {\n        return items[i]\n    }\n}\n\nstruct GenericStack<Element>: Container {\n    // 연관 타입으로 제네릭 타입을 사용\n    var items: [Element] = []\n    mutating func append(_ item: Element) {\n        items.append(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["이 예제에서는 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"IntStack","position":{"start":{"line":55,"column":9,"offset":1472},"end":{"line":55,"column":19,"offset":1482}}}],"position":{"start":{"line":55,"column":9,"offset":1472},"end":{"line":55,"column":19,"offset":1482}}},"children":"IntStack"}}],"은 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Int","position":{"start":{"line":55,"column":21,"offset":1484},"end":{"line":55,"column":26,"offset":1489}}}],"position":{"start":{"line":55,"column":21,"offset":1484},"end":{"line":55,"column":26,"offset":1489}}},"children":"Int"}}]," 타입을 사용하지만, ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"GenericStack","position":{"start":{"line":55,"column":38,"offset":1501},"end":{"line":55,"column":52,"offset":1515}}}],"position":{"start":{"line":55,"column":38,"offset":1501},"end":{"line":55,"column":52,"offset":1515}}},"children":"GenericStack"}}],"은 제네릭 타입 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Element","position":{"start":{"line":55,"column":61,"offset":1524},"end":{"line":55,"column":70,"offset":1533}}}],"position":{"start":{"line":55,"column":61,"offset":1524},"end":{"line":55,"column":70,"offset":1533}}},"children":"Element"}}],"를 사용합니다. 이는 해당 스택이 어떤 타입의 요소든 받을 수 있도록 유연하게 설계되었습니다."]}],"\n",["$","h2",null,{"id":"c6090caf","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"프로토콜을 통한 다양한 타입 제약"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Swift에서는 프로토콜을 통해 다양한 타입 제약을 설정할 수 있습니다. 특히 연관 타입을 사용하는 경우 이런 제약이 더욱 유용해집니다. 다음 예제를 통해 살펴보겠습니다."}],"\n",["$","pre","pre-2",{"children":["$","$Ld",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"protocol Summable {\n    static func +(lhs: Self, rhs: Self) -> Self\n}\n\nprotocol SummableContainer: Container where Item: Summable {\n    func sum() -> Item\n}\n\nextension Array: SummableContainer where Element: Summable {\n    typealias Item = Element\n    func sum() -> Element {\n        return reduce(Element(), +)\n    }\n}\n\nextension Int: Summable {}\nextension Double: Summable {}\n"}],"position":{"start":{"line":61,"column":1,"offset":1707},"end":{"line":79,"column":4,"offset":2097}}},"children":"protocol Summable {\n    static func +(lhs: Self, rhs: Self) -> Self\n}\n\nprotocol SummableContainer: Container where Item: Summable {\n    func sum() -> Item\n}\n\nextension Array: SummableContainer where Element: Summable {\n    typealias Item = Element\n    func sum() -> Element {\n        return reduce(Element(), +)\n    }\n}\n\nextension Int: Summable {}\nextension Double: Summable {}\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["위 예제에서 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Summable","position":{"start":{"line":81,"column":8,"offset":2106},"end":{"line":81,"column":18,"offset":2116}}}],"position":{"start":{"line":81,"column":8,"offset":2106},"end":{"line":81,"column":18,"offset":2116}}},"children":"Summable"}}]," 프로토콜은 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"+","position":{"start":{"line":81,"column":25,"offset":2123},"end":{"line":81,"column":28,"offset":2126}}}],"position":{"start":{"line":81,"column":25,"offset":2123},"end":{"line":81,"column":28,"offset":2126}}},"children":"+"}}]," 연산자를 사용할 수 있도록 타입을 제약합니다. 그리고 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"SummableContainer","position":{"start":{"line":81,"column":59,"offset":2157},"end":{"line":81,"column":78,"offset":2176}}}],"position":{"start":{"line":81,"column":59,"offset":2157},"end":{"line":81,"column":78,"offset":2176}}},"children":"SummableContainer"}}]," 프로토콜은 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Item","position":{"start":{"line":81,"column":85,"offset":2183},"end":{"line":81,"column":91,"offset":2189}}}],"position":{"start":{"line":81,"column":85,"offset":2183},"end":{"line":81,"column":91,"offset":2189}}},"children":"Item"}}],"이 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Summable","position":{"start":{"line":81,"column":93,"offset":2191},"end":{"line":81,"column":103,"offset":2201}}}],"position":{"start":{"line":81,"column":93,"offset":2191},"end":{"line":81,"column":103,"offset":2201}}},"children":"Summable"}}],"을 준수하는 타입이어야 한다는 제약을 갖습니다. 이를 통해 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"sum()","position":{"start":{"line":81,"column":136,"offset":2234},"end":{"line":81,"column":143,"offset":2241}}}],"position":{"start":{"line":81,"column":136,"offset":2234},"end":{"line":81,"column":143,"offset":2241}}},"children":"sum()"}}]," 메서드를 사용하여 모든 요소의 합을 구할 수 있습니다."]}],"\n",["$","h2",null,{"id":"3c8aa85e","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"고급 활용: 제네릭과 연관 타입을 결합한 실용적 예제"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"마지막으로, 제네릭과 연관 타입을 결합한 고급 활용 예제를 살펴보겠습니다. 이를 통해 실무에서 어떻게 이런 개념들을 활용해 코드를 구조화할 수 있는지 보여드리겠습니다."}],"\n",["$","pre","pre-3",{"children":["$","$Ld",null,{"props":{"className":"language-swift","node":{"type":"element","tagName":"code","properties":{"className":["language-swift"]},"children":[{"type":"text","value":"protocol NetworkRequest {\n    associatedtype Response\n    func sendRequest(completion: @escaping (Response) -> Void)\n}\n\nstruct StringRequest: NetworkRequest {\n    typealias Response = String\n    func sendRequest(completion: @escaping (String) -> Void) {\n        // 예: 네트워크 요청을 보내고 응답으로 문자열을 받음\n        let response = \"This is a response\"\n        completion(response)\n    }\n}\n\nstruct GenericRequest<T>: NetworkRequest {\n    typealias Response = T\n    func sendRequest(completion: @escaping (T) -> Void) {\n        // 예: 네트워크 요청을 보내고 응답으로 제네릭 타입을 받음\n        // 여기서는 단순히 전달된 값을 반환한다고 가정\n        let response = T.self\n        completion(response as! T) // 강제 언래핑은 일반적으로 사용하지 않습니다.\n    }\n}\n\nfunc performRequest<R: NetworkRequest>(request: R) {\n    request.sendRequest { response in\n        print(\"Response: \\(response)\")\n    }\n}\n"}],"position":{"start":{"line":87,"column":1,"offset":2403},"end":{"line":117,"column":4,"offset":3238}}},"children":"protocol NetworkRequest {\n    associatedtype Response\n    func sendRequest(completion: @escaping (Response) -> Void)\n}\n\nstruct StringRequest: NetworkRequest {\n    typealias Response = String\n    func sendRequest(completion: @escaping (String) -> Void) {\n        // 예: 네트워크 요청을 보내고 응답으로 문자열을 받음\n        let response = \"This is a response\"\n        completion(response)\n    }\n}\n\nstruct GenericRequest<T>: NetworkRequest {\n    typealias Response = T\n    func sendRequest(completion: @escaping (T) -> Void) {\n        // 예: 네트워크 요청을 보내고 응답으로 제네릭 타입을 받음\n        // 여기서는 단순히 전달된 값을 반환한다고 가정\n        let response = T.self\n        completion(response as! T) // 강제 언래핑은 일반적으로 사용하지 않습니다.\n    }\n}\n\nfunc performRequest<R: NetworkRequest>(request: R) {\n    request.sendRequest { response in\n        print(\"Response: \\(response)\")\n    }\n}\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["위 예제에서는 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NetworkRequest","position":{"start":{"line":119,"column":9,"offset":3248},"end":{"line":119,"column":25,"offset":3264}}}],"position":{"start":{"line":119,"column":9,"offset":3248},"end":{"line":119,"column":25,"offset":3264}}},"children":"NetworkRequest"}}],"라는 제네릭 프로토콜을 정의하고, 이를 준수하는 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"StringRequest","position":{"start":{"line":119,"column":52,"offset":3291},"end":{"line":119,"column":67,"offset":3306}}}],"position":{"start":{"line":119,"column":52,"offset":3291},"end":{"line":119,"column":67,"offset":3306}}},"children":"StringRequest"}}],"와 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"GenericRequest","position":{"start":{"line":119,"column":69,"offset":3308},"end":{"line":119,"column":85,"offset":3324}}}],"position":{"start":{"line":119,"column":69,"offset":3308},"end":{"line":119,"column":85,"offset":3324}}},"children":"GenericRequest"}}],"를 구현했습니다. ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"performRequest","position":{"start":{"line":119,"column":95,"offset":3334},"end":{"line":119,"column":111,"offset":3350}}}],"position":{"start":{"line":119,"column":95,"offset":3334},"end":{"line":119,"column":111,"offset":3350}}},"children":"performRequest"}}]," 함수는 어떤 네트워크 요청이든 받아서 처리할 수 있습니다. 이는 네트워크 요청의 타입에 구애받지 않는 유연한 코드 설계를 가능하게 합니다."]}],"\n",["$","h2",null,{"id":"5b12bcf2","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"결론"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Swift에서 고급 프로토콜과 연관 타입을 활용하면 코드의 유연성과 재사용성을 극대화할 수 있습니다. 제네릭 프로토콜을 사용하면 다양한 타입 제약을 추가할 수 있으며, 이를 통해 코드의 의도를 명확히 할 수 있습니다. 실제 예제를 통해 살펴본 것처럼, 프로토콜과 연관 타입을 활용한 고급 설계를 통해 확장 가능하고 유지보수하기 쉬운 코드를 작성하는 것이 가능합니다."}]]}]}],["$","$Le",null,{}]]}],["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","$Lf",null,{"articleTitle":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법.","toc":[{"tagName":"h1","title":"고급 Swift 프로토콜과 연관 타입 활용하기: 제네릭 프로토콜과 연관 타입을 이용한 유연한 설계 방법","id":"f26746aa"},{"tagName":"h2","title":"기본 프로토콜과 연관 타입의 이해","id":"30c1b085"},{"tagName":"h2","title":"제네릭 프로토콜의 실용적 활용","id":"5bef690d"},{"tagName":"h2","title":"프로토콜을 통한 다양한 타입 제약","id":"c6090caf"},{"tagName":"h2","title":"고급 활용: 제네릭과 연관 타입을 결합한 실용적 예제","id":"3c8aa85e"},{"tagName":"h2","title":"결론","id":"5b12bcf2"}],"language":"kr"}]}]]}]]
8:null
