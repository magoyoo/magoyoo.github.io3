1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/98e4530578c425d7.css",{"as":"style"}]
0:["BTzIZmIeYXT3BlsSUt3SU",[[["",{"children":["algorithm",{"children":[["slug","BoyerMoore-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%B2%95-67de61a0","d"],{"children":["__PAGE__?{\"slug\":\"BoyerMoore-문자열-검색-알고리즘-효율적인-텍스트-검색-기법-67de61a0\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/98e4530578c425d7.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":42879,"chunks":["185:static/chunks/app/layout-b198f10c98e34978.js"],"name":"GoogleAnalytics","async":false}
6:I{"id":47767,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
7:I{"id":57920,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
3:[null,["$","html",null,{"lang":"ko","children":[["$","$L5",null,{}],["$","body",null,{"className":"__className_aaf875","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","algorithm","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","algorithm","children",["slug","BoyerMoore-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%B2%95-67de61a0","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"BoyerMoore-문자열-검색-알고리즘-효율적인-텍스트-검색-기법-67de61a0\"}"},"styles":[]}],"segment":["slug","BoyerMoore-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%B2%95-67de61a0","d"]},"styles":[]}],"segment":"algorithm"},"styles":[]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법 | 마고자비 블로그"}],["$","meta","2",{"name":"description","content":"Boyer-Moore 문자열 검색 알고리즘은 텍스트 내에서 패턴을 검색하는 데 매우 효율적인 방법입니다. 해당 알고리즘의 동작 원리, 장점과 단점, 그리고 실제 구현 예시를 통해 자세히 알아보겠습니다."}],["$","meta","3",{"name":"keywords","content":"algorithm,string search,Boyer-Moore,텍스트 검색"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"}],["$","link","5",{"rel":"canonical","href":"https://magomercy.com/algorithm/BoyerMoore-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%B2%95-67de61a0"}],["$","meta","6",{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta","7",{"name":"apple-mobile-web-app-title","content":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법 | 마고자비 블로그"}],["$","meta","8",{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta","9",{"property":"og:title","content":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법 | 마고자비 블로그"}],["$","meta","10",{"property":"og:description","content":"Boyer-Moore 문자열 검색 알고리즘은 텍스트 내에서 패턴을 검색하는 데 매우 효율적인 방법입니다. 해당 알고리즘의 동작 원리, 장점과 단점, 그리고 실제 구현 예시를 통해 자세히 알아보겠습니다."}],["$","meta","11",{"property":"og:url","content":"https://magomercy.com/algorithm/BoyerMoore-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B2%80%EC%83%89-%EA%B8%B0%EB%B2%95-67de61a0"}],["$","meta","12",{"property":"og:site_name","content":"마고자비 블로그 | 마구잡이로 하고 싶은 것을 합니다."}],["$","meta","13",{"property":"og:locale","content":"kr"}],["$","meta","14",{"property":"og:image","content":"https://magomercy.com/images/algorithmImg.jpg"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary"}],["$","meta","17",{"name":"twitter:creator","content":"마고자비 블로그"}],["$","meta","18",{"name":"twitter:title","content":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법 | 마고자비 블로그"}],["$","meta","19",{"name":"twitter:description","content":"Boyer-Moore 문자열 검색 알고리즘은 텍스트 내에서 패턴을 검색하는 데 매우 효율적인 방법입니다. 해당 알고리즘의 동작 원리, 장점과 단점, 그리고 실제 구현 예시를 통해 자세히 알아보겠습니다."}],["$","meta","20",{"name":"twitter:image","content":"https://magomercy.com/images/algorithmImg.jpg"}],["$","link","21",{"rel":"icon","href":"https://magomercy.com/favicon32.png"}],["$","link","22",{"rel":"apple-touch-icon","href":"https://magomercy.com/favicon32.png"}],["$","meta","23",{"name":"next-size-adjust"}]]
a:I{"id":22873,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
b:I{"id":84423,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
c:I{"id":2346,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
d:I{"id":67490,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"MarkDownCode","async":false}
10:I{"id":87272,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
11:I{"id":55026,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","406:static/chunks/app/algorithm/[slug]/page-94b16d6f374c2d4c.js"],"name":"","async":false}
e:T49a,# Boyer-Moore 전체 알고리즘 구현 예제
text = "HERE IS A SIMPLE EXAMPLE"
pattern = "EXAMPLE"
def boyer_moore(text, pattern):
    m = len(pattern)
    n = len(text)
    bad_char_table = [-1] * 256
    for i in range(m - 1):
        bad_char_table[ord(pattern[i])] = i
    good_suffix_table = [m] * (m + 1)
    borders = [0] * (m + 1)
    i, j = m, m + 1
    borders[i] = m + 1
    while i > 0:
        while j <= m and pattern[i - 1] != pattern[j - 1]:
            if good_suffix_table[j] == m:
                good_suffix_table[j] = j - i
            j = borders[j]
        i -= 1
        j -= 1
        borders[i] = j
    j = borders[0]
    for i in range(m + 1):
        if good_suffix_table[i] == m:
            good_suffix_table[i] = j
        if i == j:
            j = borders[j]
    shift = 0
    while shift <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[shift + j]:
            j -= 1
        if j < 0:
            print(f"Pattern found at index {shift}")
            shift += good_suffix_table[0]
        else:
            shift += max(1, j - bad_char_table[ord(text[shift + j])], good_suffix_table[j + 1])
boyer_moore(text, pattern)
f:T49a,# Boyer-Moore 전체 알고리즘 구현 예제
text = "HERE IS A SIMPLE EXAMPLE"
pattern = "EXAMPLE"
def boyer_moore(text, pattern):
    m = len(pattern)
    n = len(text)
    bad_char_table = [-1] * 256
    for i in range(m - 1):
        bad_char_table[ord(pattern[i])] = i
    good_suffix_table = [m] * (m + 1)
    borders = [0] * (m + 1)
    i, j = m, m + 1
    borders[i] = m + 1
    while i > 0:
        while j <= m and pattern[i - 1] != pattern[j - 1]:
            if good_suffix_table[j] == m:
                good_suffix_table[j] = j - i
            j = borders[j]
        i -= 1
        j -= 1
        borders[i] = j
    j = borders[0]
    for i in range(m + 1):
        if good_suffix_table[i] == m:
            good_suffix_table[i] = j
        if i == j:
            j = borders[j]
    shift = 0
    while shift <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[shift + j]:
            j -= 1
        if j < 0:
            print(f"Pattern found at index {shift}")
            shift += good_suffix_table[0]
        else:
            shift += max(1, j - bad_char_table[ord(text[shift + j])], good_suffix_table[j + 1])
boyer_moore(text, pattern)
9:[["$","$La",null,{"language":"kr","screenType":"ARTICLE_DETAIL"}],["$","section",null,{"className":"flex fixed top-0 left-0 w-full  md:h-[600px] h-[300px] justify-center","style":{"backgroundImage":"url(/images/algorithmImg.jpg)","backgroundPosition":"center","backgroundSize":"contain","backgroundRepeat":"no-repeat"},"children":[["$","div",null,{"className":"w-full md:h-[600px] h-[300px]  bg-[#171E24] bg-opacity-[0.35] absolute top-0 left-0"}],["$","div",null,{"className":"hidden md:flex flex-col justify-end w-[100%] md:w-[700px] px-[20px] pb-[100px]","children":["$","h1",null,{"className":"font-semibold text-[40px] text-gray-100 text-shadow-default z-40","children":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법"}]}]]}],["$","main",null,{"className":"flex flex-row justify-center md:py-[120px] py-[60px] bg-white md:mt-[600px] mt-[300px] relative z-30 ","children":[["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","div",null,{"className":"toc sticky top-[90px] flex flex-col","children":["$","$Lb",null,{}]}]}],["$","article",null,{"className":"flex flex-col w-full md:w-[600px] px-[20px] md:px-[0px] gap-[40px]","children":[["$","div",null,{"className":"md:hidden border-b-[0.6px] pb-[40px] border-gray-200","children":["$","h1",null,{"className":"text-[28px] font-bold leading-[150%]","children":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법"}]}],["$","div",null,{"className":"flex flex-col","children":[["$","$Lc",null,{}],["$","div",null,{"children":["작성일 : ",["$","time",null,{"children":"2024-06-22"}]]}]]}],["$","div",null,{"children":["$","div",null,{"className":"md-to-html","children":[["$","h1",null,{"id":"92790ed8","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법"}],"\n",["$","h2",null,{"id":"476966c5","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"개요"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Boyer-Moore 문자열 검색 알고리즘은 텍스트 내에서 특정 패턴을 찾는 가장 효율적인 알고리즘 중 하나입니다. R.S. Boyer와 J.S. Moore가 1977년에 개발한 이 알고리즘은 머신러닝, 데이터 압축, 생명과학 및 정보 보안 등 다양한 분야에서 널리 사용됩니다. 이 글에서는 Boyer-Moore 알고리즘의 동작 원리 및 구현 방법, 장단점에 대해 설명하겠습니다."}],"\n",["$","h2",null,{"id":"f545fdd2","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"알고리즘의 동작 원리"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["Boyer-Moore 알고리즘은 주어진 텍스트와 패턴을 매칭할 때, 비교를 오른쪽에서 왼쪽으로 수행하며, 불일치가 발생할 경우 다음 가능한 위치로 빠르게 이동하는 방법을 사용합니다. 이 알고리즘은 ",["$","strong",null,{"className":"font-black","children":"Bad Character Rule"}],"과 ",["$","strong",null,{"className":"font-black","children":"Good Suffix Rule"}]," 두 가지 주요 규칙을 이용하여 불필요한 비교를 최소화합니다."]}],"\n",["$","h3",null,{"id":"4d689392","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"Bad Character Rule"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Bad Character Rule","position":{"start":{"line":11,"column":1,"offset":492},"end":{"line":11,"column":21,"offset":512}}}],"position":{"start":{"line":11,"column":1,"offset":492},"end":{"line":11,"column":21,"offset":512}}},"children":"Bad Character Rule"}}],"은 텍스트 내에서 패턴과 일치하지 않는 문자가 발견될 때, 해당 문자를 기준으로 패턴을 이동시키는 규칙입니다. 만약 일치하지 않는 문자가 패턴 내에 존재한다면 가장 오른쪽에 위치한 해당 문자로 패턴을 이동시킵니다. 패턴 내에 존재하지 않는 경우 패턴을 다음 위치로 이동시킵니다."]}],"\n",["$","pre","pre-0",{"children":["$","$Ld",null,{"props":{"className":"language-python","node":{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"# Bad Character Rule 예제 코드\ntext = \"ABABABACD\"\npattern = \"ABAC\"\ndef bad_character_rule(text, pattern):\n    m = len(pattern)\n    n = len(text)\n    bad_char_table = [-1] * 256\n    for i in range(m - 1):\n        bad_char_table[ord(pattern[i])] = i\n    shift = 0\n    while shift <= n - m:\n        j = m - 1\n        while j >= 0 and pattern[j] == text[shift + j]:\n            j -= 1\n        if j < 0:\n            print(f\"Pattern found at index {shift}\")\n            shift += (m - bad_char_table[ord(text[shift + m])] if shift + m < n else 1)\n        else:\n            shift += max(1, j - bad_char_table[ord(text[shift + j])])\nbad_character_rule(text, pattern)\n"}],"position":{"start":{"line":13,"column":1,"offset":669},"end":{"line":34,"column":4,"offset":1336}}},"children":"# Bad Character Rule 예제 코드\ntext = \"ABABABACD\"\npattern = \"ABAC\"\ndef bad_character_rule(text, pattern):\n    m = len(pattern)\n    n = len(text)\n    bad_char_table = [-1] * 256\n    for i in range(m - 1):\n        bad_char_table[ord(pattern[i])] = i\n    shift = 0\n    while shift <= n - m:\n        j = m - 1\n        while j >= 0 and pattern[j] == text[shift + j]:\n            j -= 1\n        if j < 0:\n            print(f\"Pattern found at index {shift}\")\n            shift += (m - bad_char_table[ord(text[shift + m])] if shift + m < n else 1)\n        else:\n            shift += max(1, j - bad_char_table[ord(text[shift + j])])\nbad_character_rule(text, pattern)\n"}}]}],"\n",["$","h3",null,{"id":"cdcb5159","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"Good Suffix Rule"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":[["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Good Suffix Rule","position":{"start":{"line":37,"column":1,"offset":1359},"end":{"line":37,"column":19,"offset":1377}}}],"position":{"start":{"line":37,"column":1,"offset":1359},"end":{"line":37,"column":19,"offset":1377}}},"children":"Good Suffix Rule"}}],"은 패턴 내에서 부분적으로 일치하는 접미사가 발견될 때, 전체 패턴을 왼쪽으로 이동시키는 규칙입니다. 즉, 이미 매칭된 접미사를 기반으로 나머지 부분이 일치할 수 있는지 검사하여 필요한 만큼만 이동시킵니다."]}],"\n",["$","pre","pre-1",{"children":["$","$Ld",null,{"props":{"className":"language-python","node":{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"# Good Suffix Rule 예제 코드\ntext = \"ABABABACD\"\npattern = \"ABAC\"\ndef good_suffix_rule(text, pattern):\n    m = len(pattern)\n    n = len(text)\n    good_suffix_table = [0] * (m + 1)\n    borders = [0] * (m + 1)\n    i, j = m, m + 1\n    borders[i] = m + 1\n    while i > 0:\n        while j <= m and pattern[i - 1] != pattern[j - 1]:\n            if good_suffix_table[j] == 0:\n                good_suffix_table[j] = j - i\n            j = borders[j]\n        i -= 1\n        j -= 1\n        borders[i] = j\n    j = borders[0]\n    for i in range(m + 1):\n        if good_suffix_table[i] == 0:\n            good_suffix_table[i] = j\n        if i == j:\n            j = borders[j]\n    shift = 0\n    while shift <= n - m:\n        j = m - 1\n        while j >= 0 and pattern[j] == text[shift + j]:\n            j -= 1\n        if j < 0:\n            print(f\"Pattern found at index {shift}\")\n            shift += good_suffix_table[0]\n        else:\n            shift += good_suffix_table[j + 1]\ngood_suffix_rule(text, pattern)\n"}],"position":{"start":{"line":39,"column":1,"offset":1494},"end":{"line":75,"column":4,"offset":2501}}},"children":"# Good Suffix Rule 예제 코드\ntext = \"ABABABACD\"\npattern = \"ABAC\"\ndef good_suffix_rule(text, pattern):\n    m = len(pattern)\n    n = len(text)\n    good_suffix_table = [0] * (m + 1)\n    borders = [0] * (m + 1)\n    i, j = m, m + 1\n    borders[i] = m + 1\n    while i > 0:\n        while j <= m and pattern[i - 1] != pattern[j - 1]:\n            if good_suffix_table[j] == 0:\n                good_suffix_table[j] = j - i\n            j = borders[j]\n        i -= 1\n        j -= 1\n        borders[i] = j\n    j = borders[0]\n    for i in range(m + 1):\n        if good_suffix_table[i] == 0:\n            good_suffix_table[i] = j\n        if i == j:\n            j = borders[j]\n    shift = 0\n    while shift <= n - m:\n        j = m - 1\n        while j >= 0 and pattern[j] == text[shift + j]:\n            j -= 1\n        if j < 0:\n            print(f\"Pattern found at index {shift}\")\n            shift += good_suffix_table[0]\n        else:\n            shift += good_suffix_table[j + 1]\ngood_suffix_rule(text, pattern)\n"}}]}],"\n",["$","h2",null,{"id":"de6302be","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"알고리즘의 장점과 단점"}],"\n",["$","h3",null,{"id":"0e91a822","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"장점"}],"\n",["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong",null,{"className":"font-black","children":"높은 효율성"}],": Boyer-Moore 알고리즘은 최악의 경우에도 O(n + m) 시간 복잡도를 가지며, 보통의 경우 대부분의 문자 비교를 건너뛰므로 매우 빠르게 동작합니다."]}],"\n",["$","li","li-1",{"children":[["$","strong",null,{"className":"font-black","children":"적은 비교 횟수"}],": 패턴의 뒤쪽부터 비교를 시작하기 때문에, 정확한 매칭이 이루어지지 않는 경우 많은 비교를 피할 수 있습니다."]}],"\n"]}],"\n",["$","h3",null,{"id":"7c7251f1","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"단점"}],"\n",["$","ol","ol-1",{"children":["\n",["$","li","li-0",{"children":[["$","strong",null,{"className":"font-black","children":"준비 시간"}],": Bad Character Rule 및 Good Suffix Rule을 적용하기 위해 초기 테이블 구성을 필요로 하며, 이는 초기 알고리즘 준비 시간이 다소 길어질 수 있습니다."]}],"\n",["$","li","li-1",{"children":[["$","strong",null,{"className":"font-black","children":"메모리 사용량"}],": 테이블을 생성하고 저장해야 하기 때문에 추가적인 메모리 공간이 필요합니다."]}],"\n"]}],"\n",["$","h2",null,{"id":"748c4215","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"실제 구현 예제"}],"\n",["$","pre","pre-2",{"children":["$","$Ld",null,{"props":{"className":"language-python","node":{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"$e"}],"position":{"start":{"line":87,"column":1,"offset":2899},"end":{"line":126,"column":4,"offset":4070}}},"children":"$f"}}]}],"\n",["$","h2",null,{"id":"5b12bcf2","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"결론"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"Boyer-Moore 문자열 검색 알고리즘은 높은 효율성 덕분에 다양한 분야에서 매우 유용하게 사용되고 있습니다. Bad Character Rule과 Good Suffix Rule을 통해 불필요한 비교를 최소화하며 빠른 검색을 제공합니다. 하지만 초기 테이블의 구성을 위해 필요한 시간과 추가적인 메모리 사용량이 단점으로 작용할 수 있습니다. 이를 충분히 고려하여 상황에 맞는 알고리즘을 선택하는 것이 중요합니다."}]]}]}],["$","$L10",null,{}]]}],["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","$L11",null,{"articleTitle":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법","toc":[{"tagName":"h1","title":"Boyer-Moore 문자열 검색 알고리즘: 효율적인 텍스트 검색 기법","id":"92790ed8"},{"tagName":"h2","title":"개요","id":"476966c5"},{"tagName":"h2","title":"알고리즘의 동작 원리","id":"f545fdd2"},{"tagName":"h3","title":"Bad Character Rule","id":"4d689392"},{"tagName":"h3","title":"Good Suffix Rule","id":"cdcb5159"},{"tagName":"h2","title":"알고리즘의 장점과 단점","id":"de6302be"},{"tagName":"h3","title":"장점","id":"0e91a822"},{"tagName":"h3","title":"단점","id":"7c7251f1"},{"tagName":"h2","title":"실제 구현 예제","id":"748c4215"},{"tagName":"h2","title":"결론","id":"5b12bcf2"}],"language":"kr"}]}]]}]]
8:null
