1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/98e4530578c425d7.css",{"as":"style"}]
0:["BTzIZmIeYXT3BlsSUt3SU",[[["",{"children":["javascript",{"children":[["slug","Reactjs-%EC%A1%B0%EC%A0%95Reconciliation-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-UI-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-e9d41e33","d"],{"children":["__PAGE__?{\"slug\":\"Reactjs-조정Reconciliation-알고리즘-효율적인-UI-업데이트-e9d41e33\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/98e4530578c425d7.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":42879,"chunks":["185:static/chunks/app/layout-b198f10c98e34978.js"],"name":"GoogleAnalytics","async":false}
6:I{"id":47767,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
7:I{"id":57920,"chunks":["272:static/chunks/webpack-2f2428fbb7549638.js","971:static/chunks/fd9d1056-695585668d16e3fb.js","596:static/chunks/596-e6a99af3279f5db8.js"],"name":"default","async":false}
3:[null,["$","html",null,{"lang":"ko","children":[["$","$L5",null,{}],["$","body",null,{"className":"__className_aaf875","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","javascript","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","javascript","children",["slug","Reactjs-%EC%A1%B0%EC%A0%95Reconciliation-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-UI-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-e9d41e33","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"Reactjs-조정Reconciliation-알고리즘-효율적인-UI-업데이트-e9d41e33\"}"},"styles":[]}],"segment":["slug","Reactjs-%EC%A1%B0%EC%A0%95Reconciliation-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-UI-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-e9d41e33","d"]},"styles":[]}],"segment":"javascript"},"styles":[]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트 | 마고자비 블로그"}],["$","meta","2",{"name":"description","content":"React.js의 조정(Reconciliation) 알고리즘은 효율적으로 사용자 인터페이스(UI)를 업데이트하는 핵심 기술입니다. 이 알고리즘의 작동 방식과 성능 최적화를 위한 방법을 탐구합니다."}],["$","meta","3",{"name":"keywords","content":"React.js,Reconciliation,UI 업데이트,알고리즘"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"}],["$","link","5",{"rel":"canonical","href":"https://magomercy.com/javascript/Reactjs-%EC%A1%B0%EC%A0%95Reconciliation-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-UI-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-e9d41e33"}],["$","meta","6",{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta","7",{"name":"apple-mobile-web-app-title","content":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트 | 마고자비 블로그"}],["$","meta","8",{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta","9",{"property":"og:title","content":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트 | 마고자비 블로그"}],["$","meta","10",{"property":"og:description","content":"React.js의 조정(Reconciliation) 알고리즘은 효율적으로 사용자 인터페이스(UI)를 업데이트하는 핵심 기술입니다. 이 알고리즘의 작동 방식과 성능 최적화를 위한 방법을 탐구합니다."}],["$","meta","11",{"property":"og:url","content":"https://magomercy.com/javascript/Reactjs-%EC%A1%B0%EC%A0%95Reconciliation-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-UI-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-e9d41e33"}],["$","meta","12",{"property":"og:site_name","content":"마고자비 블로그 | 마구잡이로 하고 싶은 것을 합니다."}],["$","meta","13",{"property":"og:locale","content":"kr"}],["$","meta","14",{"property":"og:image","content":"https://magomercy.com/images/javascriptBanner2.jpg"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary"}],["$","meta","17",{"name":"twitter:creator","content":"마고자비 블로그"}],["$","meta","18",{"name":"twitter:title","content":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트 | 마고자비 블로그"}],["$","meta","19",{"name":"twitter:description","content":"React.js의 조정(Reconciliation) 알고리즘은 효율적으로 사용자 인터페이스(UI)를 업데이트하는 핵심 기술입니다. 이 알고리즘의 작동 방식과 성능 최적화를 위한 방법을 탐구합니다."}],["$","meta","20",{"name":"twitter:image","content":"https://magomercy.com/images/javascriptBanner2.jpg"}],["$","link","21",{"rel":"icon","href":"https://magomercy.com/favicon32.png"}],["$","link","22",{"rel":"apple-touch-icon","href":"https://magomercy.com/favicon32.png"}],["$","meta","23",{"name":"next-size-adjust"}]]
a:I{"id":22873,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"","async":false}
b:I{"id":84423,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"","async":false}
c:I{"id":2346,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"","async":false}
d:I{"id":67490,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"MarkDownCode","async":false}
e:I{"id":87272,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"","async":false}
f:I{"id":55026,"chunks":["986:static/chunks/986-5f83c849e7b0dffa.js","754:static/chunks/754-8b5d90286cb88ad9.js","543:static/chunks/543-fe4d83430fed7822.js","172:static/chunks/app/javascript/[slug]/page-5d9f0fdf07008d20.js"],"name":"","async":false}
9:[["$","$La",null,{"language":"kr","screenType":"ARTICLE_DETAIL"}],["$","section",null,{"className":"flex fixed top-0 left-0 w-full  md:h-[600px] h-[300px] justify-center","style":{"backgroundImage":"url(/images/javascriptBanner2.jpg)","backgroundPosition":"center","backgroundSize":"contain","backgroundRepeat":"no-repeat"},"children":[["$","div",null,{"className":"w-full md:h-[600px] h-[300px]  bg-[#171E24] bg-opacity-[0.35] absolute top-0 left-0"}],["$","div",null,{"className":"hidden md:flex flex-col justify-end w-[100%] md:w-[700px] px-[20px] pb-[100px]","children":["$","h1",null,{"className":"font-semibold text-[40px] text-gray-100 text-shadow-default z-40","children":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트"}]}]]}],["$","main",null,{"className":"flex flex-row justify-center md:py-[120px] py-[60px] bg-white md:mt-[600px] mt-[300px] relative z-30 ","children":[["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","div",null,{"className":"toc sticky top-[90px] flex flex-col","children":["$","$Lb",null,{}]}]}],["$","article",null,{"className":"flex flex-col w-full md:w-[600px] px-[20px] md:px-[0px] gap-[40px]","children":[["$","div",null,{"className":"md:hidden border-b-[0.6px] pb-[40px] border-gray-200","children":["$","h1",null,{"className":"text-[28px] font-bold leading-[150%]","children":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트"}]}],["$","div",null,{"className":"flex flex-col","children":[["$","$Lc",null,{}],["$","div",null,{"children":["작성일 : ",["$","time",null,{"children":"2024-07-30"}]]}]]}],["$","div",null,{"children":["$","div",null,{"className":"md-to-html","children":[["$","h1",null,{"id":"b128a0e3","className":"md:text-[42px] text-[26px] font-bold leading-[150%] md:py-[50px] py-[30px] text-gray-900","children":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"React.js는 사용자 인터페이스(UI)를 구축하는 데 널리 사용되는 JavaScript 라이브러리입니다. React의 가장 큰 장점 중 하나는 변경된 부분만을 업데이트하는 효율적인 방식으로, 이를 가능하게 하는 핵심 요소가 바로 조정(Reconciliation) 알고리즘입니다. 이 글에서는 React의 조정 알고리즘이 어떻게 작동하는지, 그리고 이를 통해 효율적인 UI 업데이트를 어떻게 달성하는지에 대해 자세히 알아보겠습니다."}],"\n",["$","h2",null,{"id":"3ddfac7e","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"조정 알고리즘의 개요"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["조정 알고리즘은 번거로운 DOM 조작을 최소화하고 성능을 최적화하기 위해 도입되었습니다. React는 컴포넌트의 상태 또는 속성이 변경될 때마다 전체 UI를 다시 렌더링하는 대신, 변경된 부분만을 효율적으로 업데이트합니다. 이 과정에서 두 가지 버전의 UI 트리를 비교하여 서로 다른 부분을 찾아냅니다. 이 비교 과정이 바로 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"조정","position":{"start":{"line":8,"column":183,"offset":493},"end":{"line":8,"column":187,"offset":497}}}],"position":{"start":{"line":8,"column":183,"offset":493},"end":{"line":8,"column":187,"offset":497}}},"children":"조정"}}],"입니다."]}],"\n",["$","h3",null,{"id":"71bb8bda","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"가상 DOM(Virtual DOM)"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["조정 알고리즘의 개념을 이해하기 위해선 여기에 사용되는 가상 DOM(Virtual DOM)을 알아야 합니다. 가상 DOM은 실제 DOM의 가벼운 사본으로, 메모리 내에서 작동합니다. React는 상태나 속성이 변경될 때마다 새로운 가상 DOM을 생성하고, 이전 가상 DOM과 새로운 가상 DOM을 비교합니다. 이 과정을 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Diffing","position":{"start":{"line":12,"column":180,"offset":707},"end":{"line":12,"column":189,"offset":716}}}],"position":{"start":{"line":12,"column":180,"offset":707},"end":{"line":12,"column":189,"offset":716}}},"children":"Diffing"}}],"이라 합니다."]}],"\n",["$","h2",null,{"id":"1c198a3f","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"Diffing 알고리즘"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"React의 Diffing 알고리즘은 2013년 페이스북에서 논문으로 처음 발표되었으며, 매우 효율적으로 설계되었습니다. Diffing 알고리즘의 주요 단계는 다음과 같습니다."}],"\n",["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":[["$","strong",null,{"className":"font-black","children":"노드 유형이 다른 경우"}],": 두 노드의 유형이 다른 경우, React는 두 노드를 완전히 다른 것으로 간주하고, 이전 노드를 제거한 후 새로운 노드를 삽입합니다."]}],"\n",["$","li","li-1",{"children":[["$","strong",null,{"className":"font-black","children":"텍스트 노드 비교"}],": 두 노드가 모두 텍스트 노드일 경우, 텍스트 내용을 비교하여 다를 경우 내용을 업데이트합니다."]}],"\n",["$","li","li-2",{"children":[["$","strong",null,{"className":"font-black","children":"트리 구조 비교"}],": 재귀적으로 하위 트리까지 내려가며 노드를 비교합니다. 각 노드는 key라는 고유한 식별자를 가지며, 이 key를 통해 동일한 노드를 식별합니다."]}],"\n"]}],"\n",["$","h3",null,{"id":"39e91f0a","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"Key의 중요성"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"노드 비교를 최적화하기 위해 key 속성이 매우 중요합니다. key는 고유한 값으로 설정해야 하며, 일반적으로 리스트에서 각 아이템의 식별자로 사용됩니다. 예를 들어, 리스트 아이템을 다시 배열하거나 추가, 삭제할 때 key 속성 덕분에 React는 어떤 노드가 변경되었는지 쉽게 파악할 수 있습니다."}],"\n",["$","h2",null,{"id":"2e02a45c","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"최적화 기법"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"React에서는 UI 업데이트 성능을 최적화하기 위한 다양한 기법이 제공됩니다. 그 중 몇 가지를 살펴보겠습니다."}],"\n",["$","h3",null,{"id":"da39a3ee","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":[["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate","position":{"start":{"line":30,"column":5,"offset":1372},"end":{"line":30,"column":28,"offset":1395}}}],"position":{"start":{"line":30,"column":5,"offset":1372},"end":{"line":30,"column":28,"offset":1395}}},"children":"shouldComponentUpdate"}}]," 메서드"]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["클래스 컴포넌트에서 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate","position":{"start":{"line":32,"column":12,"offset":1412},"end":{"line":32,"column":35,"offset":1435}}}],"position":{"start":{"line":32,"column":12,"offset":1412},"end":{"line":32,"column":35,"offset":1435}}},"children":"shouldComponentUpdate"}}]," 메서드를 오버라이드하면 컴포넌트가 업데이트될지 여부를 결정할 수 있습니다. 이 메서드는 다음과 같이 사용할 수 있습니다."]}],"\n",["$","pre","pre-0",{"children":["$","$Ld",null,{"props":{"className":"language-javascript","node":{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"class MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // 조건에 따라 true 또는 false를 반환\n    return nextProps.someValue !== this.props.someValue;\n  }\n}\n"}],"position":{"start":{"line":34,"column":1,"offset":1505},"end":{"line":41,"column":4,"offset":1709}}},"children":"class MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // 조건에 따라 true 또는 false를 반환\n    return nextProps.someValue !== this.props.someValue;\n  }\n}\n"}}]}],"\n",["$","h3",null,{"id":"da39a3ee","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":[["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"React.memo","position":{"start":{"line":43,"column":5,"offset":1715},"end":{"line":43,"column":17,"offset":1727}}}],"position":{"start":{"line":43,"column":5,"offset":1715},"end":{"line":43,"column":17,"offset":1727}}},"children":"React.memo"}}],"와 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PureComponent","position":{"start":{"line":43,"column":19,"offset":1729},"end":{"line":43,"column":34,"offset":1744}}}],"position":{"start":{"line":43,"column":19,"offset":1729},"end":{"line":43,"column":34,"offset":1744}}},"children":"PureComponent"}}]]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["함수형 컴포넌트에서는 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"React.memo","position":{"start":{"line":45,"column":13,"offset":1758},"end":{"line":45,"column":25,"offset":1770}}}],"position":{"start":{"line":45,"column":13,"offset":1758},"end":{"line":45,"column":25,"offset":1770}}},"children":"React.memo"}}],"를 사용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트가 동일한 props로 재렌더링되는 것을 방지합니다."]}],"\n",["$","pre","pre-1",{"children":["$","$Ld",null,{"props":{"className":"language-javascript","node":{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"const MyComponent = React.memo(function MyComponent(props) {\n  return <div>{props.value}</div>;\n});\n"}],"position":{"start":{"line":47,"column":1,"offset":1837},"end":{"line":51,"column":4,"offset":1954}}},"children":"const MyComponent = React.memo(function MyComponent(props) {\n  return <div>{props.value}</div>;\n});\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["클래스 컴포넌트에서는 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PureComponent","position":{"start":{"line":53,"column":13,"offset":1968},"end":{"line":53,"column":28,"offset":1983}}}],"position":{"start":{"line":53,"column":13,"offset":1968},"end":{"line":53,"column":28,"offset":1983}}},"children":"PureComponent"}}],"를 사용할 수 있습니다. ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PureComponent","position":{"start":{"line":53,"column":42,"offset":1997},"end":{"line":53,"column":57,"offset":2012}}}],"position":{"start":{"line":53,"column":42,"offset":1997},"end":{"line":53,"column":57,"offset":2012}}},"children":"PureComponent"}}],"는 기본적인 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate","position":{"start":{"line":53,"column":64,"offset":2019},"end":{"line":53,"column":87,"offset":2042}}}],"position":{"start":{"line":53,"column":64,"offset":2019},"end":{"line":53,"column":87,"offset":2042}}},"children":"shouldComponentUpdate"}}]," 메서드를 제공하여, props와 state가 변경된 경우에만 재렌더링을 수행합니다."]}],"\n",["$","pre","pre-2",{"children":["$","$Ld",null,{"props":{"className":"language-javascript","node":{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"class MyComponent extends React.PureComponent {\n  render() {\n    return <div>{this.props.value}</div>;\n  }\n}\n"}],"position":{"start":{"line":55,"column":1,"offset":2091},"end":{"line":61,"column":4,"offset":2217}}},"children":"class MyComponent extends React.PureComponent {\n  render() {\n    return <div>{this.props.value}</div>;\n  }\n}\n"}}]}],"\n",["$","h3",null,{"id":"3bed0605","className":"md:text-[24px] text-[20px] font-medium leading-[140%] md:py-[30px] py-[18px] text-gray-800","children":"불변성 유지"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["React는 상태 변경을 감지할 때 객체의 참조가 변경되었는지 여부를 확인합니다. 따라서 상태를 업데이트할 때 불변성을 유지하는 것이 중요합니다. 아래와 같이 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"spread 연산자","position":{"start":{"line":65,"column":90,"offset":2320},"end":{"line":65,"column":102,"offset":2332}}}],"position":{"start":{"line":65,"column":90,"offset":2320},"end":{"line":65,"column":102,"offset":2332}}},"children":"spread 연산자"}}],"나 ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Object.assign","position":{"start":{"line":65,"column":104,"offset":2334},"end":{"line":65,"column":119,"offset":2349}}}],"position":{"start":{"line":65,"column":104,"offset":2334},"end":{"line":65,"column":119,"offset":2349}}},"children":"Object.assign"}}],"을 사용하여 새로운 객체를 생성하여 상태를 업데이트할 수 있습니다."]}],"\n",["$","pre","pre-3",{"children":["$","$Ld",null,{"props":{"className":"language-javascript","node":{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"this.setState(prevState => ({\n  items: [...prevState.items, newItem]\n}));\n"}],"position":{"start":{"line":67,"column":1,"offset":2388},"end":{"line":71,"column":4,"offset":2479}}},"children":"this.setState(prevState => ({\n  items: [...prevState.items, newItem]\n}));\n"}}]}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":"또는"}],"\n",["$","pre","pre-4",{"children":["$","$Ld",null,{"props":{"className":"language-javascript","node":{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"this.setState(prevState => ({\n  details: Object.assign({}, prevState.details, { age: 30 })\n}));\n"}],"position":{"start":{"line":75,"column":1,"offset":2485},"end":{"line":79,"column":4,"offset":2598}}},"children":"this.setState(prevState => ({\n  details: Object.assign({}, prevState.details, { age: 30 })\n}));\n"}}]}],"\n",["$","h2",null,{"id":"5b12bcf2","className":"md:text-[32px] text-[22px] font-semibold leading-[145%] md:py-[30px] py-[20px] text-gray-800","children":"결론"}],"\n",["$","p",null,{"className":"md:text-[16px] text-[15px] leading-[180%] text-gray-800 md:py-[20px] py-[20px]","children":["React의 조정 알고리즘은 변경된 부분만을 효율적으로 업데이트하여 최적의 성능을 제공합니다. 이는 가상 DOM과 Diffing 알고리즘 덕분에 가능합니다. 또한, 최적화를 위해 key 속성의 사용, ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate","position":{"start":{"line":83,"column":113,"offset":2719},"end":{"line":83,"column":136,"offset":2742}}}],"position":{"start":{"line":83,"column":113,"offset":2719},"end":{"line":83,"column":136,"offset":2742}}},"children":"shouldComponentUpdate"}}]," 메서드, ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"React.memo","position":{"start":{"line":83,"column":142,"offset":2748},"end":{"line":83,"column":154,"offset":2760}}}],"position":{"start":{"line":83,"column":142,"offset":2748},"end":{"line":83,"column":154,"offset":2760}}},"children":"React.memo"}}],", ",["$","$Ld",null,{"props":{"node":{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"PureComponent","position":{"start":{"line":83,"column":156,"offset":2762},"end":{"line":83,"column":171,"offset":2777}}}],"position":{"start":{"line":83,"column":156,"offset":2762},"end":{"line":83,"column":171,"offset":2777}}},"children":"PureComponent"}}]," 및 불변성 유지와 같은 기법을 잘 활용하면 더욱 효율적인 UI 업데이트가 가능합니다. React를 사용하여 복잡한 UI를 구축할 때, 조정 알고리즘의 작동 방식을 이해하고 적절히 활용하는 것은 매우 중요합니다."]}]]}]}],["$","$Le",null,{}]]}],["$","div",null,{"className":"xl:flex hidden w-[300px]","children":["$","$Lf",null,{"articleTitle":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트","toc":[{"tagName":"h1","title":"React.js 조정(Reconciliation) 알고리즘: 효율적인 UI 업데이트","id":"b128a0e3"},{"tagName":"h2","title":"조정 알고리즘의 개요","id":"3ddfac7e"},{"tagName":"h3","title":"가상 DOM(Virtual DOM)","id":"71bb8bda"},{"tagName":"h2","title":"Diffing 알고리즘","id":"1c198a3f"},{"tagName":"h3","title":"Key의 중요성","id":"39e91f0a"},{"tagName":"h2","title":"최적화 기법","id":"2e02a45c"},{"tagName":"h3","title":"$undefined","id":""},{"tagName":"h3","title":"$undefined","id":""},{"tagName":"h3","title":"불변성 유지","id":"3bed0605"},{"tagName":"h2","title":"결론","id":"5b12bcf2"}],"language":"kr"}]}]]}]]
8:null
